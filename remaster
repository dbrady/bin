#!/bin/bash
# remaster - pull down latest master, merge, rebundle and rerun database migrations, then rebase master into the current branch.
#
# 1. STASH     git stash
# 2. GO            go master
# 3. PULL              git pull
# 4. BUNDLE            bundle install
# 5. MIGRATE           rails db:migrate
# 6. RETURN        go -
# 7. REBASE    git rebase master
# 8. APPLY     git stash apply

# TODO:
# 1. Port this to ruby. The options are just too insane.
# 2. add -p, --pretend option to show the remastering plan/commands
# 3. add -m, --no-migration option to skip db:migrate
# 4. add -r, --no-rebase to skip rebasing master into this branch
# 5. add -b, --no-bundle to skip running bundle install
# 6. add -d, --done option to return to master and stay there. Abandon (delete?) the current branch.

# 7. Know which repos have a master branch by another name (main, develop,
# etc). Unsure if the community has standardized on non-master names yet, but if
# worse comes to worst I could add a .rc file that remembers the main branch
# name for a repo or folder. Could also add -n <name_of_main_branch> option.

# If you are not on master, this will stash, go to master, pull and merge, rebundle, remigrate, stash apply, return to your branch and rebase.

# If you ARE on master, this will pull and merge, rebundle, and remigrate.

# If you are on master, this will

# TODO: allow reset or stash option to git reset --hard beforehand to wipe
# and abandon local changes, or to git stash changes (and potentially git stash
# apply them afterwards)

# TODO: have a way to say either "stay on master" or "come back here and rebase
# master" afterwards
QUICK="false"
DONE="false" # if true, do not return to story branch

while getopts "hq" opt; do
    case ${opt} in
        h )
            echo "remaster - pull down and rebase onto latest master"
            echo
            echo "Usage:"
            echo "    remaster [options]"
            echo
            echo "-h    Show this help message"
            echo "-q    Quick mode - do not rebundle gems or remigrate the database"
            echo "-d    Done mode - done with this branch, go back to master and stay there"
            exit 1
            ;;

        q )
            QUICK="true"
            ;;
        d )
            DONE="true"
            ;;
    esac
done

BRANCH=`git branch | grep '*' | awk '{print $2}'`
git isclean
ISCLEAN=$?

# 1. STASH
if [ "$ISCLEAN" == "0" ]; then
    echo "Branch is clean, NOT stashing..."
else
    echo "Branch is dirty, stashing changes..."
    echo "git stash"
    git stash
fi

if [ "master" == "$BRANCH" ]; then
    echo "You are on master, staying put..."
else
    # 2. GO
    echo "You are NOT on master, hopping to master..."
    # this uses ~/bin/git-main to find the main/develop/master branch
    echo "git main"
    git main
fi

# 3. PULL
echo git pull
git pull

if [ $QUICK == "false" ]; then
    # 4. BUNDLE
    echo bundle install
    bundle install

    # 4.5 YARN/WEBPACK
    if [ -e "package.json" ]; then
        echo yarn
        yarn
    fi

    # 5. MIGRATE
    echo remigrate
    remigrate
else
    echo "Quick mode - skipping bundle install"
    echo "Quick mode - skipping remigrate"
fi

if [ "master" == "$BRANCH" ]; then
    echo "You were on master, staying put..."
else
    if [ $DONE == "false" ]; then
        # 6. RETURN
        echo "You were on $BRANCH, hopping back..."
        echo "go $BRANCH"
        go $BRANCH

        # 7. REBASE
        echo "Rebasing master into branch"
        echo git rebase master
        git rebase master
    else
        # 6. NO RETURN; REBASE ALREADY DONE
        echo "Done with that branch; staying on master"
    fi
fi

# 8. APPLY
if [ "$ISCLEAN" == "0" ]; then
    echo "Branch was clean, no stash apply..."
else
    echo "Branch was dirty, reapplying stashed changes..."
    echo "git stash apply"
    git stash apply
fi
