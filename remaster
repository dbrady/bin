#!/bin/bash
# remaster - pull down latest master, merge, rebundle and rerun database migrations, then rebase master into the current branch.
#
# 1. STASH     git stash
# 2. GO            go master
# 3. PULL              git pull
# 4. BUNDLE            bundle install
# 5. MIGRATE           rails db:migrate
# 6. RETURN        go -
# 7. REBASE    git rebase master
# 8. APPLY     git stash apply

# TODO:
# 1. Port this to ruby. The options are just too insane.
# 2. add -p, --pretend option to show the remastering plan/commands
# 3. add -m, --no-migration option to skip db:migrate
# 4. add -r, --no-rebase to skip rebasing master into this branch
# 5. add -b, --no-bundle to skip running bundle install
# 6. add -d, --done option to return to master and stay there. Abandon (delete?) the current branch.

# 7. Know which repos have a master branch by another name (main, develop,
# etc). Unsure if the community has standardized on non-master names yet, but if
# worse comes to worst I could add a .rc file that remembers the main branch
# name for a repo or folder. Could also add -n <name_of_main_branch> option.

# If you are not on master, this will stash, go to master, pull and merge, rebundle, remigrate, stash apply, return to your branch and rebase.

# If you ARE on master, this will pull and merge, rebundle, and remigrate.

# If you are on master, this will

# TODO: allow reset or stash option to git reset --hard beforehand to wipe
# and abandon local changes, or to git stash changes (and potentially git stash
# apply them afterwards)

# TODO: have a way to say either "stay on master" or "come back here and rebase
# master" afterwards
QUICK="false"
DONE="false" # if true, do not return to story branch


# --------------------------------------------------------------------------------
# DANGER: echo needs -e on linux and on pre-Catalina OSX IN BASH BUT NOT SH.
#
# Remember when Apple made stuff just work instead of bragging about stuff just
# working that didn't?
#
# echo needs -e on linux and on pre-Catalina OSX. -e is undocumented on OSX; on
# Catalina it will silently work, EXCEPT if you use this log message and then
# pass more than one argument from bin/sh. Then it will print the -e, followed
# by the colorized message. But it DOES work silently, correctly, if you pass a
# single argument by wraping the args in quotes. Bleh.
#
# Example:
# log() { echo -e "${COLOR}$@${CLEAR}" }

# log "this is a message"
# => 1this is a message2 # where 1 and 2 turn color on and off
#
# log this is a message
# => -e 1this is a message2 # where 1 and 2 turn color on and off
#
# 2021-08-23: At the time of this writing I only need this to run on Catalina,
# not on any other OSX and not on linux. Future Me can decide if we want/need to
# detect OS and switch between echo formats. 2021-08-23: UPDATE: just use
# bin/bash everywhere, and -e will always be required and will always not print.
# --------------------------------------------------------------------------------
log() {
    echo -e "\033[32m$@\033[0m"
}

while getopts "hq" opt; do
    case ${opt} in
        h )
            echo "remaster - pull down and rebase onto latest master"
            echo
            echo "Usage:"
            echo "    remaster [options]"
            echo
            echo "-h    Show this help message"
            echo "-q    Quick mode - do not rebundle gems or remigrate the database"
            echo "-d    Done mode - done with this branch, go back to master and stay there"
            exit 1
            ;;

        q )
            QUICK="true"
            ;;
        d )
            DONE="true"
            ;;
    esac
done

BRANCH=`git branch | grep '*' | awk '{print $2}'`
git isclean
ISCLEAN=$?

# 1. STASH
if [ "$ISCLEAN" == "0" ]; then
    log "Branch is clean, NOT stashing..."
else
    log "Branch is dirty, stashing changes..."
    log "git stash"
    git stash
fi

if [ "master" == "$BRANCH" ]; then
    log "You are on master, staying put..."
else
    # 2. GO
    log "You are NOT on master, hopping to master..."
    # this uses ~/bin/git-main to find the main/develop/master branch
    log "git main"
    git main
fi

# 3. PULL
log git pull
git pull

if [ $QUICK == "false" ]; then
    # 4. BUNDLE
    log bundle install
    bundle install

    # 4.5 YARN/WEBPACK
    if [ -e "package.json" ]; then
        log yarn
        yarn
    fi

    # 5. MIGRATE
    log remigrate
    remigrate
else
    log "Quick mode - skipping bundle install"
    log "Quick mode - skipping remigrate"
fi

if [ "master" == "$BRANCH" ]; then
    log "You were on master, staying put..."
else
    if [ $DONE == "false" ]; then
        # 6. RETURN
        log "You were on $BRANCH, hopping back..."
        log "go $BRANCH"
        go $BRANCH

        # 7. REBASE
        log "Rebasing master into branch"
        log git rebase master
        git rebase master
    else
        # 6. NO RETURN; REBASE ALREADY DONE
        log "Done with that branch; staying on master"
    fi
fi

# 8. APPLY
if [ "$ISCLEAN" == "0" ]; then
    log "Branch was clean, no stash apply..."
else
    log "Branch was dirty, reapplying stashed changes..."
    log "git stash apply"
    git stash apply
fi
