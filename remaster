#!/bin/bash
# remaster - pull down latest master, merge, rebundle and rerun database migrations, then rebase master into the current branch.

# 1. STASH                  : git stash
# 2. GO                     : go main
# 3. PULL                   : git pull
# 4. BUNDLE                 : bundle install
# 5. MIGRATE                : rails db:migrate (only if schema has changed)
# 6. RETURN                 : go - (only if we were on a story branch)
# 7. REBASE                 : git rebase main
# 8. APPLY                  : git stash apply (only if we stashed changes)

# TODO:

# 1. [TODO] Port this to ruby. The options are just too insane. Also do this, if
# for no other reason, to give a high-level imperative script at the top like
# git_stash; go_master; git_pull... return_to_story_branch, git_rebase,
# git_stash_apply, etc.
# 2. [TODO] add -p, --pretend option to show the remastering plan/commands
# 3. [DONE] add -q, --quick mode to skip bundling and migrations
# 4. [DONE] add -d, --done option to return to master and stay there. Abandon (delete?) the current branch.
# 5. [DONE] (Done: Use git-main, which uses git-main-branch.) Know which repos
# have a master branch by another name (main, develop, etc). Unsure if the
# community has standardized on non-master names yet, but if worse comes to
# worst I could add a .rc file that remembers the main branch name for a repo or
# folder. Could also add -n <name_of_main_branch> option.

QUICK="false"
DONE="false" # if true, do not return to story branch

log() {
    # Need -e to show colors in bash
    # must be omitted in sh (will print a literal "-e")
    echo -e "\033[32m$@\033[0m"
}

while getopts "hq" opt; do
    case ${opt} in
        h )
            echo "remaster - pull down and rebase onto latest main branch"
            echo
            echo "Usage:"
            echo "    remaster [options]"
            echo
            echo "-h    Show this help message"
            echo "-q    Quick mode - do not rebundle gems or remigrate the database"
            echo "-d    Done mode - done with this branch, go back to main and stay there"
            exit 1
            ;;

        q )
            QUICK="true"
            ;;
        d )
            DONE="true"
            ;;
    esac
done

BRANCH=`git branch | grep '*' | awk '{print $2}'`
MAIN_BRANCH=`git main-branch`
git isclean
ISCLEAN=$?

# 1. STASH
if [ "$ISCLEAN" == "0" ]; then
    log "Branch is clean, NOT stashing..."
else
    log "Branch is dirty, stashing changes..."
    log "git stash"
    git stash
fi

if [ "$MAIN_BRANCH" == "$BRANCH" ]; then
    log "You are already on main branch '$BRANCH', staying put..."
    DONE="true"
else
    # 2. GO
    log "You are NOT on main branch, hopping to $MAIN_BRANCH..."
    log "go $MAIN_BRANCH"
    go $MAIN_BRANCH
fi

# 3. PULL
log git pull
git pull

if [ $QUICK == "false" ]; then
    # 4. BUNDLE
    log bundle install
    bundle install

    # 5. MIGRATE
    log "remigrate -f"
    remigrate -f

    # 5.5 sometimes bundle modifies Gemfile.lock and migrate alters db:seeds,
    # and we don't care/want this.  Ideally I'd like to fix these files if they
    # have changed, but I probably want to port this to ruby first.
    #
    # TODO: If this changes ONLY because I'm on the wrong version of bundler,
    # I'll get grief trying to start the server that I need to run bundle
    # install first. Maybe figure that out, idk.
    # git restore Gemfile.lock
    # git restore db/seeds.rb
else
    log "Quick mode - skipping bundle install"
    log "Quick mode - skipping remigrate"
fi

if [ "$MAIN_BRANCH" == "$BRANCH" ]; then
    log "You were on main branch, staying put..."
else
    if [ $DONE == "false" ]; then
        # 6. RETURN
        log "You were on $BRANCH, hopping back..."
        log "go $BRANCH"
        go $BRANCH

        # 7. REBASE
        log "Rebasing branch onto tip of main branch '$MAIN_BRANCH'..."
        log git rebase $MAIN_BRANCH
        git rebase $MAIN_BRANCH
    else
        # 6. NO RETURN; REBASE ALREADY DONE
        log "Done with that branch; staying on main branch"
    fi
fi

# 8. APPLY
if [ "$ISCLEAN" == "0" ]; then
    log "Branch was clean, no stash apply..."
else
    log "Branch was dirty, reapplying stashed changes..."
    log "git stash apply"
    git stash apply
fi
