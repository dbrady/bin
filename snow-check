#!/usr/bin/env ruby
# snow-check - Automatically check a file for known snowflake migration problems

# TODO: --essential flag maybe? It would flag things that HAVE to be fixed to
# even see if Snowflake will work. Then --all (or omit --essential) would let me
# do code cleanup for the PR.

# TODO: Autofix problems if possible?
#
# e.g. if we see ^\s*(DISTKEY|(COMPOUND\s+)?SORTKEY)<rest of expression>\s*$, so
# we know there's NOTHING else on the line, we can just fix it by removing that
# line from the array. Maybe if we did -i,--interactive to say "show me the
# problem, show me the intended fix, and then let me pick". Then it could remove
# the line, rewrite the file, present for git commit, add it and commit with
# standard message. BOOM.

# TODO: Long/slow jobs. Think some on how to make use of the time during the
# "test redshift", "test snowflake", and "confirm snowflake" steps.

# TODO: Parallel work. Right now (2022-07-27) I wouldn't dare try to start a new
# ticket with the old one waiting for Zack to want changes all over
# it. Hopefully that will happen naturally with time and experience. Right now I
# would get CRAZY lost in the checklist.

# TODO: Interactive/tracking checklist. Sthg like reset the checklist, check off
# the checklist, show the checklist in progress. Supercool if it could be
# hot/interactive, like just keep a screen up with the checklist, and type
# "snow-check done 3" and have item 3 tick off the list, etc. Probably not worth
# the effort but man that does sound cool.

# TODO: This is an app now. Grow up, put on some pants, and get some class

def checklist
  i=0
  return <<THE_LIST
#{i=i+1}. Claim the ticket and move it to In Development
#{i=i+1}. export SCRIPT=job_filename.py; export JOB=$(echo $SCRIPT | sed -e 's/\.py//')
#{i=i+1}. Make sure you're on latest feature/snowflake-moveover
   #{i}.1 (cd /root/data_services/etl/warehouse && git co feature/snowflake-moveover && git pull)
   #{i}.2 (cd /root/data_services/etl/warehouse/finance && git co feature/snowflake-moveover && git pull)
#{i=i+1}. Cut a new feature branch as feature/DS-{ticket}/{job_name} IN BOTH REPOS
   #{i}.1 (cd /root/data_services/etl/warehouse && git new-branch NUM JOB_NAME)
   #{i}.2 (cd /root/data_services/etl/warehouse/finance && git new-branch NUM JOB_NAME)
#{i=i+1}. PRECHECK THE JOB! See if it has a --test or --skip_upload, and always use them
#{i=i+1}. Run the job in redshift because who knows if it even works
#{i=i+1}. Run snow-check --essential to fix stuff that CAN'T work in Snowflake
#{i=i+1}. Change the nightly config from redshift to snowflake
#{i=i+1}. Ensure job runs in Snowflake (compare data in both databases)
#{i=i+1}. Run snow-check and clean up style things
#{i=i+1}. Inspect the code for any other egregious style concerns
   #{i}.1. Don't stomp another maintainer's style (egregious concerns only)
   #{i}.2. Put any new ones in snow-check, even if just "(Check by hand)"
#{i=i+1}. Ensure job STILL runs in Snowflake
#{i=i+1}. Screenshot it and attach it to the JIRA ticket
#{i=i+1}. Open a PR in warehouse to merge it into feature/snowflake-moveover
#{i=i+1}. Open a PR in finance to merge the redshift->snowflake change into its
    feature/snowflake-moveover branch
#{i=i+1}. Sanity-check the PRs
   #{i}.1. Ensure you are merging into feature/snowflake-moveover, NOT MASTER
   #{i}.2. Ensure the commit stream has JUST the commits you made for this PR
   #{i}.3. Inspect the PR file changes on GitHub
   #{i}.4. Check the PR titles, it will probably grab the first commit comment
#{i=i+1}. Fix Up All The Links
    #{i}.1. Put the JIRA ticket into the PRs.
    #{i}.2. In JIRA: Put PR numbers in the JIRA ticket.
    #{i}.3. In OSX.bash, Call set-pr on the warehouse and finance branches
    TODO: Make a script to do this AND emit the link text for JIRA and Zack?
    Like "fix-links 1785 2455 134" that emits
    """
    **DS-1785:**
    Jira Ticket: http/aoeusntho/DS-1785
    Warehouse PR: hpttaoeu/pulls/2455
    Finance PR: http/.aoeu/pulls/134
    """
    Paste lines where needed. (Slack: CMD-V SHIFT+CMD+F to paste and format)
    Bonus: Automatically copy to clipboard via pbcopy
    Bonus: Autamatically call set-pr on the two folders (UNLESS ALREADY SET?)
#{i=i+1}. Move JIRA ticket to IN REVIEW
#{i=i+1}. DELEGATE: Notify Zack by sending him links to the case and both PRs
#{i=i+1}. If Zack has concerns: fix and resubmit to him until he's :+1:
#{i=i+1}. WAITING ON: Watch ticket for being merged into snowflake branch by Zack
#{i=i+1}. Move Jira ticket to Closed
THE_LIST
end

# Was this script invoked with --essential?
def essential?
  ARGV.include?('--essential') || ARGV.include?('-e')
end

# Was this script invoked with --list?
def list?
  ARGV.include?('--list') || ARGV.include?('-l')
end

if list?
  puts checklist
  exit 0
end

def section_title(title)
  "====%s" % " #{title} ".ljust(80, "=")
end

def detect_and_print_lines(lines, title, regex, essential: false, disabled: false)
  return if disabled
  return if essential? && !essential
  if lines.any? { |line| line =~ regex }
    puts section_title title
    lines.each.with_index do |line, index|
      puts "%4d: %s" % [index+1, line] if line =~ regex
    end
  end
end

def usage
  puts "I COULD be bothered to parse ARGV, but I don't want YOU to be bothered typing allagaddam time. Sorry not sorry, you're welcome."
  puts "Try doing this, and maybe put it in .bashrc while you're at it:"
  puts "export SCRIPT=#{ARGV.join(' ')}"
end

if !ARGV.empty? && File.exists?(ARGV.first) && ENV.has_key?("SCRIPT") && ENV["SCRIPT"] != ARGV.first
  puts "HEY! You gave me an ARGV to run on #{ARGV.first.inspect}"
  puts "But I use the SCRIPT var, which is #{ENV['SCRIPT'].inspect}"
  usage
  exit -1
end

unless ENV.has_key?("SCRIPT")
  puts "You must set SCRIPT=<filename> first."
  if !ARGV.empty?
    usage
  end
  exit -1
end

lines = IO.readlines(ENV['SCRIPT']).map(&:rstrip)

# show pep8 violations
if !essential?
  puts section_title("PEP8 CONFORMANCE")
  system "pep-check #{ENV['SCRIPT']}"
end

# ----------------------------------------------------------------------
# Illegal Snowflake Syntax: DISTKEY, SORTKEY
# ----------------------------------------------------------------------
# DISTKEY, SORTKEY: just remove, it's fine
detect_and_print_lines lines, "DISTKEY / SORTKEYS", /\b(DIS|SOR)TKEY\b/i, essential: true


# ----------------------------------------------------------------------
# Illegal Snowflake Syntax:  INTERVAL
# ----------------------------------------------------------------------
#
# Don't use postgresq2l date interval arithmetic. Instead of
#
# Instead of
# WHERE timestamp::DATE >= CURRENT_DATE - INTERVAL '2 days'
#
# We have to use DATEADD or DATEDIFF:
#
# WHERE timestamp >= DATEADD(day, -2, CURRENT_DATE)
# WHERE DATEDIFF(day, timestamp, CURRENT_DATE) <= 2
detect_and_print_lines lines, "Interval Arithmetic", /\bINTERVAL\b/i, essential: true

detect_and_print_lines lines, "Postgresql integer extension types", /\bINT(2|4|8)\b/i, essential: true


# ----------------------------------------------------------------------
# NPM-style Lists
# ----------------------------------------------------------------------
# This one's not set in stone. It's a style I deeply dislike, but I
# won't pull it if the entire file is consistent. If there are multiple
# blocks and they're ALL in NPM style, I'll leave it alone. If there's a mix or
# if there's only one block, change it.
detect_and_print_lines lines, "NPM-style Lists (Leading Commas)", /^\s*,\s*\S+/, disabled: true


# ----------------------------------------------------------------------
# Update Python String Formatting
# ----------------------------------------------------------------------
detect_and_print_lines lines, "Python 2 String Formatting", /%[\d\.]*[sdf].*['"]\s*%/


# ----------------------------------------------------------------------
# os.chdir to self: remove
# ----------------------------------------------------------------------
# If we see this exact line, just remove it:
# os.chdir(os.path.dirname(os.path.abspath(__file__)))
#
# If we see another os.chdir, flag it as a warning.
detect_and_print_lines lines, "Potentially Useless os.chdir", /\bos.chdir\b/


# ----------------------------------------------------------------------
# except Exception
#
# ----
# TODO: Detect this exact block:
#     except Exception as e:
#       etl_client.close()
#       raise
#
#     and replace with:
#
#     finally:
#       etl_client.close()
# ----

detect_and_print_lines lines, "Global Exception Handling", /\bexcept Exception\b/


# ----------------------------------------------------------------------
# Outdented SQL
detect_and_print_lines lines, "Outdented SQL (Not Fully Implemented - Check By Hand)", /^(FROM|WHERE|JOIN) /

# ----------------------------------------------------------------------
# Long lines
detect_and_print_lines lines, "Egregiously Long Lines (Check by hand)", /^.{120,}$/

# ----------------------------------------------------------------------
# Overcomplicated format() calls
detect_and_print_lines lines, "Overly short format() calls (Check by hand)", /\.format\([^){,20}]\)/

# ----------------------------------------------------------------------
# Remove reflexive formats, e.g. "{var}".format(var=var)
#
# DON'T do this in SQL statements. SublimeText can't grok SQL in f"" strings, so
# Kym and Rikki favor the explicit format() call instead.
#
# Research this, I know it can be done with Oniguruma with sth like /\.format\(.*<?foo:[\w_]+>=<foo>.*\)/
# detect_and_print_lines lines, "Reflexive format() calls (Check by hand - DON'T REMOVE FROM SQL STATEMENTS)", /\.format\([^){,20}]\)/
