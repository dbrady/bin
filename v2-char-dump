#!/usr/bin/env ruby
# frozen_string_literal: true
# v2-char-dump - dump a v2 png character as json
require "base64"
require "colorize"
require "json"
require "optimist"
require "pathname"
$:.unshift(File.expand_path("~/bin/lib"))
require "dbrady_cli"
String.disable_colorization unless $stdout.tty?

class Application
  include DbradyCli
  PNG_SIGNATURE = "\x89PNG\r\n\x1a\n".b

  attr_reader :infile, :outfile

  opt_flag :auto, :description, :first

  def run
    @opts = Optimist.options do
      banner <<BANNER
v2-char-dump <infile.png> [<outfile.json>] - dump a v2 png character as json

Options:
BANNER
      opt :auto,        "Automatically set json filename from source", default: false
      opt :debug,       "Print extra debug info", default: false
      opt :description, "Render the character description field", short: :D, default: false
      opt :first,       "Render the first_mes field", short: :f, default: false
      opt :pretend,     "Print commands but do not run them", default: false
      opt :quiet,       "Run with minimal output", default: false
      opt :verbose,     "Run with verbose output (overrides --quiet)", default: false
    end
    opts[:quiet] = !opts[:verbose] if opts[:verbose_given]
    if debug?
      puts opts.sort.to_h.inspect
      puts "opt_flags: (#{opt_flags.size})"
      opt_flags.each do |flag|
        flag_method = "#{flag}?"
        puts "#{flag_method}: #{public_send(flag_method).inspect}"
      end
      puts "opt_readers: (#{opt_readers.size})"
      opt_readers.each do |reader|
        puts "#{reader}: #{public_send(reader).inspect}"
      end
    end
    Optimist.educate if ARGV.empty? # Remove this if your script takes no args

    @infile, @outfile = ARGV

    @outfile = if @outfile.nil?
                 if auto?
                   File.open(Pathname(infile).sub_ext('.json').to_s, "w")
                 else
                   $stdout
                 end
               else
                 File.open(outfile, "w")
               end

    run!
  end

  def run!
    text_value = extract_text_chunk(ARGV[0])
    spec = decode_character_spec(text_value)

    if description?
      outfile.puts spec["description"].gsub("\\r\\n", "\n")
    elsif first?
      outfile.puts spec["first_mes"].gsub("\\r\\n", "\n")
    else
      outfile.puts JSON.pretty_generate(spec)
    end
  end

  def extract_text_chunk(file_path)
    File.open(file_path, 'rb') do |f|
      signature = f.read(8)
      raise "Invalid PNG file" unless signature == PNG_SIGNATURE

      until f.eof?
        length_data = f.read(4)
        break unless length_data
        length = length_data.unpack1('N')
        chunk_type = f.read(4)
        data = f.read(length)
        crc = f.read(4) # Ignored

        if chunk_type == 'tEXt'
          key, value = data.split("\x00", 2)
          return value if key.downcase.include?('char') || key.downcase.include?('meta')
        end
      end
    end

    raise "No relevant tEXt chunk found"
  end

  def decode_character_spec(text_data)
    begin
      decoded = Base64.decode64(text_data)
    rescue
      raise "Base64 decode failed"
    end

    begin
      json = JSON.parse(decoded)
    rescue => e
      raise "JSON parse failed: #{e.message}"
    end

    json['data'] or raise "Missing 'data' field in JSON"
  end
end


if __FILE__ == $0
  Application.new.run
end
