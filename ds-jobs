#!/usr/bin/env ruby
require 'colorize'
require 'csv'
require 'optimist'
require 'text-table'

users = {
  "31b95b7de045" => "dave",
  "-1" => "kanav",
  "5c83d468efbb" => "kenton",
  "b58cf084a090" => "kym",
  "1bb4fcfc3ac9" => "rikki",
  "98909e115b88" => "zack",
}
host_case_sql = "CASE " \
                + users
                    .each_pair
                    .map {|host, name| "WHEN host='#{host}' THEN '#{name}'" }
                    .join(' ') \
                + " ELSE host END"

# TODO: update me with my list of known old hostnames (I have one, sadly)
hostname=`hostname`.strip
raise "Hey you have a hardcoded hostname of '31b95b7de045' but your hostname is '#{hostname}', what gives?" if hostname != '31b95b7de045'

opts = Optimist::options do
  opt :warehouse, "Warehouse", short: :none, type: :string, default: "snowflake"
  opt :limit, "Max jobs to return", short: :none, default: 20
  opt :job, "Job name or path/to/job.py (or CSV if multiple)", short: :none, type: :string
  opt :start, "Show jobs started on or after this datetime (always UTC)", short: :none, type: :string
  opt :end, "Show jobs started (not ended!) on or before this datetime (always UTC)", short: :none, type: :string
  opt :host, "Hostname", short: :none, type: :string
  opt :mine, "Same as --host=#{hostname}", short: :none, default: false
  opt :notes, "Show notes column", short: :none, default: false
  opt :where, "Override where clause entirely", short: :none, type: :string
  opt :utc, "Show times in UTC", short: :none, default: false
  opt :failures, "Show failures only", short: :none, default: false

  opt :debug, "Show extra debugging", default: false
  opt :pretend, "Show query and exit", default: false
  opt :quiet, "Suppress output other than the jobs results", default: false
end
Optimist::die "Cannot specify --host and --mine at same time" if opts[:mine] && opts[:host_given]
puts opts.inspect if opts[:debug]

opts[:job] = opts[:job].gsub(%r|/|,".").sub(/\.py$/,'') if opts[:job_given]


opts[:host] = hostname if opts[:mine]

# optional columns
notes = ", notes " if opts[:notes]

# where clause
wheres = []

# job
if opts[:job_given]
  jobs = opts[:job].split(/,/).map {|job| "'%s'" % job.gsub(%r|/|, '.').sub(/\.py$/, '')}
  wheres << "job IN (#{jobs.join(', ')})"
end

# host
wheres << "host='#{opts[:host]}'" if opts[:mine] || opts[:host_given]

# failures
wheres << "success=0" if opts[:failures]

# start
#
# NOTE: --start and --end are always in UTC. Changing the search time per
# warehouse is easy. Knowing whether DST was active when the job ran is
# considerably less so.
wheres << "start_time >= '#{opts[:start]}'" if opts[:start_given]

# end
wheres << "end_time <= '#{opts[:end]}'" if opts[:end_given]


# Pack up the wheres array into a WHERE clause.
where = if opts[:where_given] && !wheres.empty?
          "WHERE\n            " + (wheres + [opts[:where]]).join("\n            AND ")
        elsif opts[:where_given]
          "WHERE #{opts[:where]}"
        elsif wheres.empty?
          ""
        else
          "WHERE " + wheres.map {|w| "\n            #{w}"}.join(" AND ")
        end

start_time_sql,
end_time_sql = if opts[:utc]
                 [
                   "start_time",
                   "end_time"
                 ]
               elsif opts[:warehouse] =~ /redshift/
                 [
                   "start_time, start_time AT TIME ZONE 'UTC' AT TIME ZONE 'America/Denver' AS start_time_mst",
                   "end_time, end_time AT TIME ZONE 'UTC' AT TIME ZONE 'America/Denver' AS end_time_mst"
                 ]
               else
                 [
                   "start_time, CONVERT_TIMEZONE('UTC', 'America/Denver', start_time) AS start_time_mst",
                   "end_time, CONVERT_TIMEZONE('UTC', 'America/Denver', end_time) AS end_time_mst"
                 ]
               end


query = if opts[:warehouse] =~ /redshift/
          <<QUERY
WITH jobs1 AS (
    SELECT
        host
        , job
        , start_time
        , end_time
        , success
        , job_failed_count
        , retry_count
        #{notes}
    FROM
        f_etl_job_details
        #{where}
        ORDER BY start_time DESC LIMIT #{opts[:limit]}
)
, jobs2 AS (
    SELECT
        host
        , job
        , start_time
        , end_time
        , DATEDIFF(second, start_time, end_time) AS duration
        , success
        , job_failed_count
        , retry_count
        #{notes}
    FROM
        jobs1
)
SELECT
    #{host_case_sql}
    , job
    , #{start_time_sql}
    , #{end_time_sql}
    , LPAD(FLOOR(duration/3600),2,0)||':'||LPAD(FLOOR(MOD(duration, 3600)/60),2,0)||':'||LPAD(MOD(duration, 60),2,0) AS elapsed
    , success
    , job_failed_count
    , retry_count
    #{notes}
FROM
    jobs2
QUERY
        else
            <<QUERY
WITH jobs1 AS (
    SELECT
        host
        , job
        , start_time
        , end_time
        , DATEDIFF('second', start_time, (CASE WHEN end_time IS NOT NULL THEN end_time ELSE CURRENT_TIMESTAMP END)) AS duration
        , success
        , job_failed_count
        , retry_count
        #{notes}
    FROM
        f_etl_job_details
        #{where}
    ORDER BY start_time DESC
    LIMIT #{opts[:limit]}
)
SELECT
    #{host_case_sql} AS host
    , job
    , #{start_time_sql}
    , #{end_time_sql}
    , LPAD(FLOOR(duration/3600),2,0)||':'||LPAD(FLOOR(MOD(duration, 3600)/60),2,0)||':'||LPAD(MOD(duration, 60),2,0) AS elapsed
    , success
    , job_failed_count
    , retry_count
FROM
    jobs1
QUERY
        end

puts query.cyan unless opts[:quiet]
exit(0) if opts[:pretend]

query = query.each_line.map(&:strip).to_a.join(' ').gsub(/\s+/, ' ')

command = if opts[:warehouse] =~ /redshift/
            %Q(dsquery --csv --warehouse #{opts[:warehouse]} --query "#{query}")
          else
            %Q(dsquery --csv --warehouse #{opts[:warehouse]} --query "#{query}")
          end

puts command.cyan if opts[:debug]
results = `#{command}`.strip

puts CSV.parse(results, headers: true).to_table(first_row_is_head: true)
