#!/usr/bin/env ruby
# frozen_string_literal: true
# lpath - print breadcrumb/path to string in one of our localization files
#
# SETUP: This script needs my personal dbrady_cli library and expects to find it
# in ~/bin/lib. You can get that here:
# https://github.com/dbrady/bin/blob/master/lib/dbrady_cli.rb
#
# TODO: This is a hamburger mess of feature creep because it's an active
# tool. Settle on what I want and make it work
require "colorize"
require "json"
require "optimist"
require "yaml"
$:.unshift(File.expand_path("~/bin/lib"))
require "dbrady_cli"
String.disable_colorization unless $stdout.tty?

class Application
  include DbradyCli

  opt_flag :case, :color, :dump, :files, :search, :views

  def run
    @opts = Optimist.options do
      banner <<BANNER
localepath - print breadcrumb/path to string in one of our localization files

localepath "string" <path/to/en.yml>

Options:
BANNER
      opt :debug, "Print extra debug info", default: false
      opt :pretend, "Print commands but do not run them", default: false
      opt :verbose, "Run with verbose output (overrides --quiet)", default: false
      opt :quiet, "Run with minimal output", default: false

      opt :case, "Perform case sensitive search", default: false
      opt :color, "Display path colorized", default: true
      opt :dump, "Dump the yaml as json", default: false
      opt :files, "Print locale filenames", short: :f, default: false
      opt :search, "Search views for i18n.t usage", short: :s, default: false
      opt :views, "Print view filenames", short: :w, default: false
    end
    opts[:quiet] = !opts[:verbose] if opts[:verbose_given]
    puts opts.sort.to_h.inspect if debug?

    Optimist.educate if ARGV.empty?
    Optimist.die "Expected 1 or 2 args, got #{ARGV.size}" unless [1,2].include?(ARGV.size)

    String.disable_colorization unless color?

    run!
  end

  def run!
    # :eyes:
    string_to_find, path = *ARGV

    if path
      run_on_file string_to_find, path
    else
      Dir.glob("config/locales/**/*.yml").each do |path|
        run_on_file string_to_find, path
      end
    end
  end

  def run_on_file(string_to_find, path_to_locale_file)
    paths_to_locale_files = Array(path_to_locale_file)
    filter_text = if string_to_find.start_with?("/") && string_to_find.end_with?("/")
                    string_to_find[1..-2]
                  else
                    Regexp.escape(string_to_find)
                  end
    filter = Regexp.new(filter_text, case? ? Regexp::IGNORECASE : nil)

    paths_to_locale_files.each do |path_to_locale_file|
      config = Psych.load_file(path_to_locale_file, aliases: true)

      puts JSON.pretty_generate(config) if dump?

      breadcrumb = find_item(config, filter, ".")

      if breadcrumb
        found_breadcrumb = breadcrumb.dup
        found_breadcrumb = found_breadcrumb.yellow if color?

        # TODO: Need a Match class to include path_to_locale_file, value, line
        # number, etc.  found_breadcrumb = "#{found_breadcrumb}:#{value}" if values?

        puts found_breadcrumb
        puts path_to_locale_file if files?

        if search?
          tag_to_search = breadcrumb.sub(/\.en\.leases./, '')
          hits = get_command_output_lines(%Q(ag --vimgrep "#{tag_to_search}" .), quiet: true)

          hits.each do |hit|
            file, line, column, text = hit.split(/:/, 4)
            if color?
              if case?
                text = text.gsub(tag_to_search) { |match| match.black.on_yellow } if color?
              end
              file = file.light_green.bold
              line = line.yellow.bold
              column = column.yellow
            end
            puts [file, line, column, text].join(':')
          end
        end
      end
    end
  end

  def find_item(hash, item, prefix)
    hash.each_pair do |key, value|
      case value

      when Hash
        breadcrumb = find_item(value, item, "#{prefix}#{key}.")
        return breadcrumb if breadcrumb

      when String
        new_prefix = "#{prefix}#{key}"
        if item.is_a?(Regexp)
          puts "#{prefix.inspect}: #{key.inspect} -> #{value.inspect} =~ #{item}" if debug?
          if value =~ item
            if color?
              key = key.yellow
              value = value.cyan
            end
            puts "#{key}: #{value}" unless quiet?
            return new_prefix
          end
        elsif case?
          if value.include?(item)
            if color?
              key = key.yellow
              value = value.cyan
            end
            puts "#{key}: #{value}" unless quiet?
            return new_prefix
          end
        else
          if value.downcase.include?(item.downcase)
            if color?
              key = key.yellow
              value = value.cyan
            end
            puts "#{key}: #{value}" unless quiet?
            return new_prefix
          end
        end
      end
    end

    # We only get here if value is a hash AND none of its subhashes have the
    # item.  I.e. this entire hash was a dry hole.
    return nil
  end
end


if __FILE__ == $0
  Application.new.run
end
