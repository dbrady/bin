#!/usr/bin/env ruby
# git new-branch <jira_id> <branch_name>
#
# Usage:
# git new-branch 5658 set_default_epot_in_merchant_settings
# => git co -b dbrady/ATL-5658/set_default_epot_in_merchant_settings
require "colorize"
require "optimist"

def usage
  usage=<<USAGE
USAGE
end

# TODO: Google harder. Read https://git-scm.com/docs/git-help more
# thoroughly. All the blogs on custom git commands boil down to
# "git-foo will give you the 'git foo' command, aren't I clever!" and
# exactly ZERO of them show how to write a custom HELP command for
# them. I want to know if 'git help new-branch' could ever work, and
# if so if it's a simple git-help-new-branch or githelp-new-branch or
# more involved like installing a custom manpage.

opts = Optimist.options do
  banner <<USAGE
git new-branch [options] <jira_id> <branch_name>

Usage:

    git new-branch 5658 set-default-epot-in-merchant-settings
    => git co -b dbrady/ATL-5658/set-default-epot-in-merchant-settings
    get new-branch --type=hotfix 1234 etl_f_this_job_is_busted
    => git co -b hotfix/DS-1234/etl_f_this_job_is_busted

Note:

    Options can only be passed in when directly running this script
    (git-new-branch), not when auto-dispatching it from git (git new-branch)

USAGE

  opt :type, 'Type of branch. Determines branch name prefix.', default: 'feature' # default: 'dbrady'
  opt :hotfix, 'Create hotfix branch. Same as --type=hotfix.'
  # This is a clever idea and it does what I want it to, but it's very
  # surprising to me for a script to change its default based on an implicit
  # external condition, so... no.  opt :job, 'Convert branch name from a
  # filename to a job.', default:
  # Dir.pwd.include?('/data_services/etl/warehouse')
  opt :job, 'Convert branch name from a filename to a job.', default: true
end
Optimist::die "Expected exactly 2 arguments, got #{ARGV.size}" unless ARGV.size == 2
Optimist::die "First argument must be a Jira ticket id" unless ARGV.first.to_i > 0

def in_warehouse?
  Dir.pwd.include?('/data_services/etl/warehouse')
end

def filename_to_job_name(name)
  name.gsub(%r|/|, ".").sub(/.py$/, "")
end

# TEAM_PREFIX='ATL'
TEAM_PREFIX='DS'
branch_type = if opts[:hotfix]
                'hotfix'
              else
                opts[:type]
              end

ticket=ARGV[0]
branch=ARGV[1]

# You know what, toggling the job option based on directory just feels strange
# and weird. Instead, let's turn it on all the time and show a warning if we're
# outside the warehouse.

current_branch = `git current-branch`.strip
old_branch = branch
branch = opts[:job] ? filename_to_job_name(branch) : branch
ticket = "#{TEAM_PREFIX}-#{ticket}" if ticket =~ /^\d+$/
full_branch_name = "#{branch_type}/#{ticket}/#{branch}"

# Show warning message IFF
#   1. the branch name IS BEING changed
#   2. --job and --no-job were not explicitly specified
#   3. we are outside the warehouse
if filename_to_job_name(branch) != old_branch && !opts[:job_given] && !in_warehouse?
  puts "Converting branch name from #{branch} to #{branch}, but we are outside the warehouse. If you did not mean this, run:".bold.white.on_yellow
  puts "git checkout #{current_branch} && git branch -d #{full_branch_name} && git-new-branch --no-job #{ARGV.join(' ')}".cyan
end


# Ensure branch name is short enough to fit through the CI mangler
# DS team doesn't use this
# if full_branch_name.size > 60
#   puts "ERROR: branch name is too long (length = #{full_branch_name.size}, must be <= 60)"
#   exit 2
# end

command = "git co -b #{full_branch_name}"
puts command
puts `#{command}`
