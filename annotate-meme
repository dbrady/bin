#!/usr/bin/env ruby
# annotate-meme <input.png> [<output.png>] - annotate an image, meme caption style
require "colorize"
require "optimist"
$:.unshift(File.expand_path("~/bin/lib"))
require "dbrady_cli"
String.disable_colorization unless $stdout.tty?

class Application
  include DbradyCli

  def bottom?; opts[:bottom_given]; end
  def top?; opts[:top_given]; end

  opt_flag :open,
           :preview
  
  opt_reader :bottom,
             :bottom_gravity,
             :bottom_pointsize,
             :bottom_y,
             :fill, 
             :font, 
             :image_width,
             :pointsize,
             :stroke,
             :stroke_width,
             :top,
             :top_gravity,
             :top_pointsize,
             :top_y
  
  def run
    @opts = Optimist.options do
      banner <<BANNER
# annotate-meme <input.png> [<output.png>] - annotate an image, meme caption style

Options:
BANNER
      opt :debug, "Print extra debug info", default: false
      opt :pretend, "Print commands but do not run them", default: false
      opt :verbose, "Run with verbose output (overrides --quiet)", default: false
      opt :quiet, "Run with minimal output", default: false

      opt :bottom, "Text to display at top", type: :string
      opt :bottom_gravity, "Gravity to anchor bottom caption", default: "South"
      opt :bottom_pointsize, "Bottom caption pointsize (overrides --pointsize)", type: :integer
      opt :bottom_y, "Vertical offset of bottom caption", default: 0
      opt :caption_width, "Maximum caption width in px", type: :integer
      opt :fill, "Caption fill color", default: "white"
      opt :font, "Font for caption", default: Application.best_font_for_this_os
      opt :open, "Open output image after creation", default: false
      opt :pointsize, "Caption pointsize", default: 144
      opt :preview, "Preview output image after creation (requires chafa)", default: false
      opt :stroke, "Caption stroke color", default: "black"
      opt :stroke_width, "Caption stroke width", default: 5
      opt :top, "Text to display at top", type: :string
      opt :top_gravity, "Gravity to anchor top caption", default: "North"
      opt :top_pointsize, "Top caption pointsize (overrides --pointsize)", type: :integer
      opt :top_y, "Vertical offset of top caption", default: 0

      # @ignore_invalid_options = true # no error given if you call this with other options (good for passthru)

      # plural types or type in [array] means multiple VALUES for this
      #   arg, but --arg can only appear once

      # multi: true means the --arg can appear multiple times, and
      #   each element will be of the type indicated.

      # If you specify both a plural type AND multi, you will get an
      #   array of arrays. See "batches" below.
      #
      #   opt :sizes, type: :ints
      #   opt :names, default: [String]
      #   opt :file, type: :string, multi: true
      #   opt :batches, type: :strings, multi: true
      #
      # How you would call these:
      #   --sizes 8 9 9                   # [8, 9, 9]
      #   --names Alice Bob Carol         # ["Alice", "Bob", "Carol"]
      #   --file=1.txt --file=2.txt       # ["1.txt", "2.txt"]
      #   --batches a b c --batches d e   # [["a","b","c"], ["d","e"]]

      # CONSTRAINTS: See https://www.manageiq.org/optimist/
      #
      # depends : # You may specify AT MOST one
      # conflicts :cat, :dog, :rat     # You may specify at most one
      # either :left, :right, :center  # You MUST specify EXACTLY one
    end
    Optimist::die "Error: you must specify at least one of --top or --bottom" unless top? || bottom?
    opts[:quiet] = !opts[:verbose] if opts[:verbose_given]
    puts opts.inspect if debug?

    on_run
  end

  def on_run
    puts "Convert Command:"
    run_command convert_command

    run_command preview_command if preview?
    run_command open_command if open?
  end
  
  def self.best_font_for_this_os
    if linux?
      "DejaVu-Sans-Bold"
    else
      "<no default font for this OS>"
    end
  end

  def preview_command
    %Q|chafa "#{output_image}"|
  end

  def open_command
    osx? ? "open" : "xdg-open"
  end
  
  def image
    @image ||= ARGV.first
  end
  
  def output_image
    puts "File.basename(image): #{File.basename(image)}" if debug?
    ext = File.extname(image)
    image_basename = image[..ext.size]
    opts[:output] || "#{image_basename}.out#{ext}"
  end

  def image_width
    width = get_command_output(%Q|identify -format "%w" "#{image}|).to_i
  end

  def pointsize_for_top
    top_pointsize || pointsize
  end
  
  def pointsize_for_bottom
    bottom_pointsize || pointsize
  end
  
  def bottom_caption
    return nil unless bottom?

    %Q|\\( -background none -fill #{fill} -stroke #{stroke} -strokewidth #{stroke_width} -font #{font} -pointsize #{pointsize_for_bottom} -size #{image_width} -gravity #{bottom_gravity} caption:"#{bottom}" \\) -gravity #{bottom_gravity} -geometry +0+#{bottom_y} -composite|
  end
  
  def top_caption
    return nil unless top?

    %Q|\\( -background none -fill #{fill} -stroke #{stroke} -strokewidth #{stroke_width} -font #{font} -pointsize #{pointsize_for_top} -size #{image_width} -gravity North caption:"#{top}" \\) -gravity #{top_gravity} -geometry +0+#{top_y} -composite|
  end
  
  def convert_command
    %Q|convert "#{image}" #{top_caption} #{bottom_caption} "#{output_image}"|
  end

  def self.linux?
    @linux ||= `uname -s`.strip == "Linux"
  end
  
end


if __FILE__ == $0
  Application.new.run
end
