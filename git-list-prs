#!/usr/bin/env ruby
# git-list-prs - list known prs for this repo
#
# EDIT: This works and it's ok, but it's a lot of ceremony. If I decide to
# embrace Sequel this high ceremony ratio will be ideal for being an example, as
# there's very little business logic to clutter up the framework code.
#
# TODO: Extract the DATABASE_PATH, DB, and PrHistory code to
# e.g. "pr_history.rb". This will make the code shareable between the git-x-pr
# scripts.

require "colorize"
require "extralite"
require "optimist"
require "sequel"
require "text-table"
require_relative "dbrady_cli"
String.disable_colorization unless $stdout.tty?

class Application
  include DbradyCli

  opt_flag :names
  opt_flag :all

  DATABASE_PATH = File.expand_path('~/bin/db/git-pr-history.db')
  DB = Sequel::sqlite(DATABASE_PATH)

  class PrHistory < Sequel::Model(DB[:pr_history])
    plugin :timestamps, update_on_create: true
  end

  # Return true if path contains a .git/ folder or a .git file (specific instance of a submodule)#
  # Duplicate code in git-branch-history and git-log-branch. Is it make-a-git-tools-gem o'clock yet?
  def is_git_repo?(path)
    File.exist?(File.join(path, '.git'))
  end

  # Walk up file tree looking for a .git folder
  # Duplicate code in git-branch-history and git-log-branch. Is it make-a-git-tools-gem o'clock yet?
  def git_repo_for(path)
    starting_path = last_path = path

    while !path.empty?
      return path if is_git_repo?(path)
      last_path, path = path, File.split(path).first
      raise " FIGURE OUT PATH FOR #{starting_path.inspect}" if last_path == path
    end
  end

  def run
    @opts = Optimist.options do
      opt :names, "Sort by names", default: false
      opt :all, "Show all results (include soft-deleted prs)", default: false

      opt :debug, "Print extra debug info", default: false
      opt :pretend, "Print commands but do not run them", default: false
      opt :verbose, "Run with verbose output (overrides --quiet)", default: false
      opt :quiet, "Run with minimal output", default: false
    end
    opts[:quiet] = !opts[:verbose] if opts[:verbose_given]
    puts opts.inspect if opts[:debug]

    repo = git_repo_for(Dir.pwd)

    prs = PrHistory.where(repo:).order(*(names? ? [:branch] : [:created_at, :id])).all
    # prs = PrHistory.where(repo:).all

    if prs.empty?
      puts "No PRs found for repo '#{repo}'"
    else
      table = Text::Table.new
      table.head = [ "Branch", "PR", "Created", "Updated"]
      table.rows = []

      prs.each do |pr|
        table.rows << [pr.branch, pr.pr, pr.created_at.strftime("%F %T"), pr.updated_at.strftime("%F %T")]
      end

      puts table
    end
  end

end


if __FILE__ == $0
  Application.new.run
end
