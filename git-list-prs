#!/usr/bin/env ruby
# git-list-prs - list known prs for this repo
#
# EDIT: This works and it's ok, but it's a lot of ceremony. I'm doing this on
# purpose: if I decide to embrace Sequel this high ceremony ratio will be ideal
# to make this be example code, as there's very little business logic here to
# clutter up the framework code.
#
# TODO: Extract the DATABASE_PATH, DB, and PrHistory code to
# e.g. "pr_history.rb". This will make the code shareable between the git-x-pr
# scripts.

require "colorize"
require "extralite"
require "optimist"
require "sequel"
require "text-table"
require_relative "dbrady_cli"
String.disable_colorization unless $stdout.tty?

class Application
  include DbradyCli

  opt_flag :names
  opt_flag :all

  DATABASE_PATH = File.expand_path('~/bin/db/git-pr-history.db')
  DB = Sequel::sqlite(DATABASE_PATH)

  class PrHistory < Sequel::Model(DB[:pr_history])
    plugin :timestamps, update_on_create: true
  end

  def run
    @opts = Optimist.options do
      opt :names, "Sort by names", default: false
      opt :all, "Show all results (include soft-deleted prs)", default: false

      opt :debug, "Print extra debug info", default: false
      opt :pretend, "Print commands but do not run them", default: false
      opt :verbose, "Run with verbose output (overrides --quiet)", default: false
      opt :quiet, "Run with minimal output", default: false
    end
    opts[:quiet] = !opts[:verbose] if opts[:verbose_given]
    puts opts.inspect if opts[:debug]

    repo = git_repo_for(Dir.pwd)

    prs = PrHistory.where(repo:).order(*(names? ? [:branch] : [:created_at, :id])).all
    # prs = PrHistory.where(repo:).all

    if prs.empty?
      puts "No PRs found for repo '#{repo}'"
    else
      table = Text::Table.new
      table.head = [ "Branch", "PR", "Created", "Updated"]
      table.rows = []

      prs.each do |pr|
        table.rows << [pr.branch, pr.pr, pr.created_at.strftime("%F %T"), pr.updated_at.strftime("%F %T")]
      end

      puts table
    end
  end

end


if __FILE__ == $0
  Application.new.run
end
