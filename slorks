#!/usr/bin/env ruby
# slorks - Track branch/pr/ticket and show slackups
#
# General Usage:
#
# slorks - generate table at terminal for my quick review
# slorks -m, --markdown - generate markdown for slackup
# slorks new [<ticket>|--board=<jira_team> --ticket=<jira_ticket_number>] --title=<title> - create new slork
# slorks delete <ticket_details> - delete a slork (ticket_details must locate exactly 1 ticket)
# slorks update <ticket_details> <new_ticket_details> (no idea how to do this. Find title then set title what)
#
# slorks [create|edit|update|list|show]
# $ slorks   --board=MPS --jira=199 --repo=merchant_portal --title='Remove spiff orders table' --status='p' --notes='blocked by MPS-209'
#

# TODO: It's time for some TODO-Driven-Development
# - [ ] slorks --interactive - interactively select ticket, status, edit note, etc
# - [ ] Order by workflow? Just need a status -> position sort order.
# - [ ] Move the Slork class into a model subdir
# - [ ] Add a --dry-run option to show all commands
# - [ ] We're big enough to warrant a proper cleanup refactoring with tests.
#   - [ ] Investigate how we're gonna run tests or rspec in here
# - [ ] FINALLY some features!
# - [ ] Add change log into the database, autoupdate it on slork change (paperclip?) and add commands to view the changelog
# - [ ] Argv Upgrading
#    - [ ] think on generalizing optimist (or just adapting my own args handler)
#      towards a <command> <subcommand> <args> structure where each command
#      could potentially open up a subinstance of optimist, like how ''rails g
#      help' and 'rails g migration help' will send the help arg to generate or
#      to migration. There's messes in there like tail args, e.g. 'foo arg -a'
#      is that foo(arg, -a) or foo.arg(-a), etc, but that's a well-studied
#      problem (Ruby solves it with precedence, 'foo arg, -a' means 'foo(arg,
#      -a)' and 'foo arg a' means 'foo(arg(-a))'. Mind you, Ruby has commas and
#      bash does not...
#   - [ ] Accept ARGV[2] as the value for setter commands, e.g. slorks notes
#     MPS-42 'This is a note' instead of slorks notes MPS-42 --notes="This is a
#     note"
# - [ ] Time tracking
#
# TODO: YAGNI Failures - Write down Nice To Haves here as we need them
# - [ ] A log of old slorks: select id, board, ticket, title, status, created_at, deleted_at, project_code, branch from slorks order by created_at;
# - [ ] slorks code <code> should work, but doesn't, because codes look like jira tickets, and we optimistically snatch the ticket from the command line before we've processed the command.
#
# TODONE:
# - [X] I can't deal with Text::Table's inability to handle ANSI colors. I need to write my own table formatter.
# - [X] Move dbradycli into a gem or library subdir (I like subdir because every so often I don't have deploy/gem install rights)
# - [X] Project codes

require 'clipboard'
require 'colorize'
require 'erb'
require 'extralite'
require 'fileutils'
require 'optimist'
require 'sequel'
require_relative 'lib/dbrady_cli'
require_relative 'lib/tiny_table'
String.disable_colorization unless $stdout.tty?

class Application
  include DbradyCli
  DEFAULT_REPO = 'merchant_portal'.freeze

  opt_flag :color,
           :created_at,
           :force,
           :fresh,
           :humanize,
           :markdown,
           :hide_branch,
           :hide_jira,
           :hide_notes,
           :hide_pr,
           :hide_repo,
           :project_code,
           :updated_at

  COMMANDS = {
    'abandon'   => 'Mark ticket as abandoned',
    'announce'  => 'Display merge announcement',
    'block'     => 'Mark ticket as blocked',
    'branch'    => 'Set branch',
    'c'         => 'Open database console',
    'console'   => 'Open database console',
    'clean'     => 'Soft-delete all deployed tickets (use after reporting them as deployed)',
    'code'      => 'Set project code',
    'commands'  => 'List commands',
    'create'    => 'Create slorks database',
    'delete'    => 'Soft-delete ticket',
    'deploy'    => 'Mark ticket as Deployed',
    'done'      => 'Mark ticket as done',
    'go'        => 'Go to branch for this ticket (git checkout)',
    'merge'     => 'Mark this ticket as merge-only (not rebasable by git remaster)',
    'new'       => 'Create new ticket (automatically called from git-new-branch)',
    'notes'     => 'Edit ticket notes',
    'pr'        => 'Edit ticket PR',
    'progress'  => 'Mark ticket as in progress',
    'qa'        => 'Mark ticket as ready for qa',
    'ready'     => 'Mark ticket as ready for deploy',
    'review'    => 'Mark ticket as in review (automatically called from git set-pr)',
    'status'    => 'Edit ticket status',
    'statuses'  => 'List statuses',
    'time'      => 'Log time against a ticket',
    'title'     => 'Edit ticket title',
    'undelete'  => 'Undelete a ticket (provide new status, default is "p")',
  }.freeze
  DATABASE_PATH = File.expand_path('~/bin/db/git-settings.db')
  DB = Sequel::sqlite(DATABASE_PATH)

  NO_LIST_COMMANDS = %w{announce commands console go statuses}

  KNOWN_STATUSES = {
    '>' => { name: 'Deferred',        colors: {mode: :normal, color: :yellow, background: :normal} },
    'D' => { name: 'Deployed',        colors: {mode: :normal, color: :green, background: :normal} },
    'R' => { name: 'Reverted',        colors: {mode: :bold,   color: :light_red, background: :normal}},
    'b' => { name: 'Blocked',         colors: {mode: :bold,   color: :white, background: :red} },
    'c' => { name: 'Cancelled',       colors: {mode: :bold,   color: :light_red, background: :normal}},
    'd' => { name: 'Ready to Deploy', colors: {mode: :bold,   color: :light_green, background: :normal} },
    'o' => { name: 'Done',            colors: {mode: :normal, color: :light_black, background: :black} }, # of a Cadillac, number one with a bullet, I'm a power pack ;^)
    'p' => { name: 'In Progress',     colors: {mode: :normal, color: :blue, background: :normal} },
    'q' => { name: 'QA Review',       colors: {mode: :normal, color: :light_magenta, background: :normal} },
    'r' => { name: 'In Review',       colors: {mode: :normal, color: :magenta, background: :normal} },
    'x' => { name: 'Abandoned',       colors: {mode: :normal, color: :light_black, background: :normal} },
  }

  if !ARGV.include?('create')
    # Slork represents one slackup entry. Class methods let you find slorks, instance methods let you work with one.
    class Slork < Sequel::Model(DB[:slorks])
      plugin :timestamps, update_on_create: true

      class <<self
        def find_ticket(board: nil, ticket: nil, title: nil, pr: nil, repo: nil, status: nil, notes: nil, deleted: false)
          search = self
          search = search.where(board:) if board
          search = search.where(ticket:) if ticket
          search = search.where(Sequel.ilike(:title, "%#{title}%")) if title
          search = search.where(pr:) if pr
          search = search.where(repo:) if repo
          search = search.where(status:) if status
          search = search.where(Sequel.ilike(:notes, "%#{notes}%")) if notes
          if deleted
            search = search.where(Sequel.~(deleted_at: nil))
          else
            search = search.where(deleted_at: nil)
          end

          search.all
        end
      end

      def ticket_key
        "#{board}-#{ticket}"
      end

      def to_s
        ticket_key
      end

      def ticket_key_and_pr
        "#{ticket_key}:#{pr}"
      end

      def pr_link
        return nil unless pr

        "https://github.com/acima-credit/#{repo}/pull/#{pr}"
      end

      def jira_link
        return nil unless board && ticket

        "https://upbd.atlassian.net/browse/#{board}-#{ticket}"
      end

      def status_text
        KNOWN_STATUSES.fetch(status, {})[:name] || status
      end

      def soft_delete!
        self.deleted_at = Time.now
        save
      end

      def move_into_review!
        self.status = 'r'
        save
      end

      def mark_ready_to_deploy!
        self.status = 'd'
        save
      end

      def mark_deployed!
        self.status = 'D'
        save
      end

      def set_pr!(pr)
        self.pr = pr
        save
      end

      def block!(reason: nil)
        self.status = 'b'
        self.notes = reason if reason
        save
      end

      def undelete!(status: 'p')
        self.deleted_at = nil
        self.status = status
        puts self.inspect if debug?
        save
      end

      def rebasable?
        !!self.rebasable
      end
    end
  end

  def run
    @opts = Optimist.options do
      banner <<BANNER.gsub(/<STATUSES>/, KNOWN_STATUSES.each_pair.map {|key,value| name = value[:name]; "  #{key}: #{name}"}.join("\n")).gsub(/<COMMANDS>/, COMMANDS.each_pair.map {|key, value| "  #{key.ljust(10)} - #{value}" }.join("\n"))
Generate and update tickets and PRs for slackup.

slorks [<command> [<ticket>]] [<options>]

slorks    - list slorks to the console and clipboard as a text table

Commands:

<COMMANDS>

Statuses:
<STATUSES>

Options:
BANNER

      # TODO: drop --board=COR, --ticket=3566 in favor of --ticket=COR-3566
      opt :board,        'Jira board', type: :string
      opt :branch,       'Branch name', type: :string
      opt :color,        'Colorize output by status', default: true
      opt :created_at,   'Show created_at timestamps', default: false
      opt :debug,        'Print extra debug info', short: :d, default: false
      opt :force,        'Force creation of a duplicate ticket if ticket already exists', short: :f, default: false
      opt :fresh,        'List freshest slorks first', short: :F, default: false
      opt :hide_branch,  'Do not display branch', short: :B, default: false
      opt :hide_jira,    'Do not display jira column', short: :J, default: false
      opt :hide_notes,   'Do not display notes column', short: :N, default: false
      opt :hide_pr,      'Do not display pr column', short: :P, default: false
      opt :hide_repo,    'Do not display repo column', short: :R, default: false
      opt :humanize,     'Humanize timestamps', default: false
      opt :markdown,     'Display output as markdown for Slack', default: false
      opt :no_color,     'Do not colorize output by status', short: :C, default: false
      opt :notes,        'Notes text', type: :string
      opt :pr,           'ID of PR', type: :int
      opt :pretend,      'Print commands but do not run them', short: :p, default: false
      opt :project_code, 'Hide project Code', default: false
      opt :quiet,        'Run with minimal output', short: :q, default: false
      opt :repo,         'Repository slug', type: :string, default: DEFAULT_REPO
      opt :status,       'Status text', type: :string
      opt :ticket,       'Jira ticket number', type: :int
      opt :title,        'Title of PR', type: :string
      opt :updated_at,   'Show updated_at timestamps', default: false
      opt :verbose,      'Run with verbose output (overrides --quiet)', short: :v, default: false
    end
    dump_opts if debug?
    opts[:quiet] = !opts[:verbose] if opts[:verbose_given]
    opts[:color] = false if opts[:no_color]

    argv = ARGV.dup
    command = argv.shift&.downcase
    board, ticket = argv.shift&.split('-')
    Optimist::die "Command #{command.inspect} must be one of: #{COMMANDS.keys.inspect}" unless command.nil? || COMMANDS.keys.include?(command)

    if command == 'create'
      ensure_table_exists!
      exit
    end

    backup_schema
    backup_database

    board, ticket = if opts[:board_given] && opts[:ticket_given]
                      # both given, slorks --board=AAA --ticket=42
                      [opts[:board], opts[:ticket]]
                    elsif ticket
                      # jira id given, slorks AAA-42
                      opts[:board], opts[:ticket] = $1, $2
                      opts[:board_given] = true
                      opts[:ticket_given] = true
                      [board, ticket]
                    elsif !opts[:board_given] && !opts[:ticket_given]
                      # No ticket and neither was given. Infer from branch name.
                      get_board_and_ticket_from_branch
                    else
                      this, that = opts[:board_given] ? [:board, :ticket] : [:ticket, :board]
                      Optimist::die "You have specified --#{this} but not --#{that}; both are required if either are present"
                    end

    puts ["Board: #{board}", "Ticket: #{ticket}"] if debug?

    case command
    when 'abandon' then mark_abandoned(board, ticket)
    when 'announce' then announce(board, ticket)
    when 'block' then block(board, ticket, opts[:notes])
    when 'branch' then set_branch(board, ticket, opts[:branch])
    when 'clean' then clean_deploys
    when 'code' then update_project_code(board, ticket)
    when 'commands' then list_commands
    when 'console', 'c' then run_command "sqlite3 -table #{DATABASE_PATH}"
    when 'delete' then soft_delete(board, ticket)
    when 'deploy' then deploy(board, ticket)
    when 'done' then mark_done(board, ticket)
    when 'go' then go_to_branch_for(board, ticket)
    when 'new' then add_new(board, ticket)
    when 'notes' then update_notes(board, ticket)
    when 'pr' then update_pr(board, ticket)
    when 'progress' then mark_in_progress(board, ticket)
    when 'qa' then mark_ready_for_qa(board, ticket)
    when 'ready' then ready(board, ticket)
    when 'review' then move_into_review(board, ticket)
    when 'status' then update_status(board, ticket)
    when 'statuses' then list_statuses
    when 'time' then record_time(board, ticket)
    when 'title' then update_title(board, ticket)
    when 'undelete' then undelete(board, ticket)
    else
      if markdown?
        puts list_as_markdown if markdown?
        copy_list_as_markdown
      else
        # copy to markdown unless --no-markdown is explicitly given
        copy_list_as_markdown unless opts[:markdown_given] && !markdown?
      end
    end
    puts list(force_nocolor: !opts[:color]) unless markdown? || NO_LIST_COMMANDS.include?(command)
    log_slorks
  end

  def list(for_log: false, force_nocolor: false)
    head = %i(ticket repo pr title status)
    head.delete(:repo) unless for_log || !hide_repo?
    head << :notes if for_log || !hide_notes?
    head << :pr_link if for_log || !hide_pr?
    head << :jira_link if for_log || !hide_jira?
    head << :branch if for_log || !hide_branch?
    head << :created_at if for_log || created_at?
    head << :updated_at if for_log || updated_at?
    head << :project_code if for_log || project_code?
    if debug?
      puts head.map.with_index {|col, index| "#{index}: #{col}" }
      puts '----------'
    end
    table = TinyTable.new(head: )

    order_column = fresh? ? :updated_at : :created_at
    Slork.where(deleted_at: nil).order(order_column, 'ASC').all.each do |slork|
      row = [slork.ticket_key]
      row << slork.repo if for_log || !hide_repo?
      row += [slork.pr, slork.title, (for_log || force_nocolor) ? slork.status_text : colorize_status(slork)]
      row << slork.notes if for_log || !hide_notes?
      row << slork.pr_link if for_log || !hide_pr?
      row << slork.jira_link if for_log || !hide_jira?
      row << slork.branch if for_log || !hide_branch?
      row << slork.project_code if for_log || project_code?
      row << display_time(slork.created_at, for_log:) if for_log || created_at?
      row << display_time(slork.updated_at, for_log:) if for_log || updated_at?
      puts row.map.with_index {|col, index| "#{index}: #{col}" } if debug?
      puts '--' if debug?
      table.rows << row
    end
    table.to_s
  end

  def announce(board, ticket)
    ticket = find_one_ticket(
      board: board,
      ticket: ticket,
      title: opts[:title],
      pr: opts[:pr],
      repo: opts[:repo],
      status: opts[:status],
      notes: opts[:notes]
    )
    puts "Announcing merge for #{ticket.ticket_key_and_pr}"

    run_command "mp-make-merge-announcement #{ticket.ticket_key_and_pr}"
  end

  def display_time(time, for_log: false)
    return time if for_log
    return nil unless time

    if humanize?
      puts "TIME NOW IS #{Time.now}"
      elapsed_seconds = Time.now - time
      days = elapsed_seconds / 86400
      hours = elapsed_seconds / 3600
      minutes = elapsed_seconds / 60

      if days > 1
        "#{'%.1f' % days} days ago"
      elsif hours > 1
        "#{'%.1f' % hours} hours ago"
      elsif minutes > 1
        "#{'%.1f' % minutes} minutes ago"
      else
        "just now"
      end
    else
      time.strftime("%Y-%m-%d %H:%M:%S")
    end
  end

  def colorize_text_by_status(status, text)
    colors = KNOWN_STATUSES.fetch(status).fetch(:colors, {mode: :normal, color: :default, background: :normal})
    text.colorize(colors)
  end

  def colorize_status(slork)
    return slork.status_text unless color?

    colorize_text_by_status(slork.status, slork.status_text)
  end

  def list_commands
    puts 'Commands:'
    longest_key = COMMANDS.keys.map(&:length).max + 1
    COMMANDS.each_pair do |key, value|
      puts "  #{(key + ":").ljust(longest_key)} #{value}"
    end
  end

  def list_statuses
    puts 'Statuses:'
    KNOWN_STATUSES.each_pair do |key, value|
      puts "  #{key}: #{colorize_text_by_status(key, value[:name])}"
    end
  end

  def copy_list_as_markdown
    Clipboard.copy(list_as_markdown)
    puts 'Slackup report copied to clipboard.' if verbose?
  end

  def log_slorks
    folder = File.expand_path "~/bin/db/logs"
    filename = "slorks.#{Time.now.strftime("%Y%m%d.%H%M%S")}.log"
    full_path = File.join folder, filename
    Dir.mkdir folder unless Dir.exist? folder

    puts "path_to_last_log: #{path_to_last_log}" if debug?
    puts "log_has_changed? #{log_has_changed?(path_to_last_log, list)}" if debug?

    the_list = list(for_log: true).join("\n") + "\n"
    if log_has_changed?(path_to_last_log, the_list)
      write_log(full_path, the_list)
    else
      puts 'No changes to log.' if verbose?
    end
  end

  def log_has_changed?(path, the_list)
    return true unless path && the_list && File.exist?(path)

    File.read(path) != the_list
  end

  def backup_database
    here = File.dirname(File.expand_path(__FILE__))
    db_file = Time.now.strftime("git-settings.%F.db")
    backup_filename = File.join(here, "db", "backups", db_file)
    src_filename = DATABASE_PATH

    FileUtils.cp(src_filename, backup_filename)
  end

  def backup_schema
    here = File.dirname(File.expand_path(__FILE__))
    schema_file = File.join(here, "db", "schema-git-settings.sql")

    run_command "sqlite3 '#{DATABASE_PATH}' '.schema --nosys --indent' > '#{schema_file}'", quiet: !verbose?
  end

  def path_to_last_log
    folder = File.expand_path "~/bin/db/logs"
    Dir.glob(File.join(folder, "slorks.*.log")).sort.last
  end

  def write_log(full_path, list)
    File.open full_path, 'w' do |f|
      f.write list
    end
    puts "Logged to #{full_path}" if verbose?
  end

  def list_as_markdown
    list = []
    slorks = Slork.where(deleted_at: nil).order(:created_at).all
    slorks.each.with_index(1) do |slork, index|
      template_lines = []
      template_lines << "*Title:* <%= slork.title %>"
      template_lines << "*Ticket:* <%= slork.jira_link %>" if slork.jira_link && !hide_jira?
      template_lines << "*PR:* <%= slork.pr_link %>" if slork.pr_link && !hide_pr?
      template_lines << "*Status:* <%= slork.status_text %>"
      template_lines << "*Notes:* <%= slork.notes %>" if slork.notes && slork.notes != "" && !hide_notes?

      template = template_lines * "\n"

      list << ERB.new(template).result(binding)
      list << '--' if index < slorks.size
    end
    list * "\n"
  end

  def ensure_table_exists!
    # slorks
    sql = <<~SQL
CREATE TABLE IF NOT EXISTS slorks (
    id integer NOT NULL PRIMARY KEY AUTOINCREMENT,
    repo varchar(255) NOT NULL,
    board varchar(255) NOT NULL,
    ticket integer NOT NULL,
    pr integer,
    title varchar(255) NOT NULL,
    status varchar(255) NOT NULL,
    notes varchar(255),
    project_code varchar(255),
    branch varchar(255),
    rebasable boolean default true,
    created_at timestamp,
    updated_at timestamp,
    deleted_at timestamp
);
SQL

    execute_query sql

    # durations
    sql = <<~SQL
CREATE TABLE IF NOT EXISTS durations (
  id         INTEGER PRIMARY KEY,
  slork_id   INTEGER NOT NULL,
  label      VARCHAR(255),
  notes      TEXT,
  ms         INTEGER NOT NULL CHECK (ms >= 0),

  created_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,

  hms TEXT GENERATED ALWAYS AS (
    printf('%d:%02d:%02d.%03d',
      CAST(ms/3600000 AS INTEGER),
      CAST(ms/60000   AS INTEGER) % 60,
      CAST(ms/1000    AS INTEGER) % 60,
      ms % 1000
    )
  ) VIRTUAL,

  FOREIGN KEY (slork_id) REFERENCES slorks(id)
);
SQL
    execute_query sql
  end

  def db
    @db ||= SQLite3::Database.new DATABASE_PATH
  end

  def execute_query(query)
    puts query.light_green if debug?
    db.execute query unless pretend?
  end

  def add_new(board, ticket)
    # if an undeleted ticket exists matching board and ticket, abort
    if !force? && Slork.find_ticket(board:, ticket:).any?
      puts 'Ticket already exists. Aborting.'.red
      exit 1
    end

    slork = Slork.new(
      board:,
      ticket:,
      repo: opts[:repo],
      pr: opts[:pr],
      title: opts[:title],
      status: opts[:status] || 'p',
      notes: opts[:notes],
      branch: opts[:branch] || git_current_branch
    )

    if debug?
      puts "add_new(#{board.inspect}, #{ticket.inspect})"
      puts slork.inspect
    end

    slork.save unless pretend?
  end

  def find_one_ticket(board: nil, ticket: nil, title: nil, pr: nil, repo: nil, status: nil, notes: nil, deleted: false)
    puts "Finding ticket: #{ {board:, ticket:, title:, pr:, repo:, status:, notes:}.inspect }" if debug?
    tickets = Slork.find_ticket(board:, ticket:, title:, pr:, repo:, status:, notes:, deleted:)

    if tickets.size != 1
      inspection = "board: #{board.inspect}, ticket: #{ticket.inspect}, title: #{title.inspect}, pr: #{pr.inspect}, repo: #{repo.inspect}, status: #{status.inspect}, notes: #{notes.inspect}, deleted: #{deleted.inspect}"
      puts "Expected exactly 1 ticket to be found, got #{tickets.size}. (Searched: #{inspection})"
      puts 'Tickets found:'
      puts tickets.map(&:values)
      raise inspection
    end

    tickets.first
  end

  def block(board, ticket, reason)
    ticket = find_one_ticket(
      board: board,
      ticket: ticket,
    )
    ticket.block!(reason: reason)
    puts 'Blocked.'
    puts ticket if debug?
  end

  def soft_delete(board, ticket)
    ticket = find_one_ticket(
      board: board,
      ticket: ticket,
      title: opts[:title],
      pr: opts[:pr],
      repo: opts[:repo],
      status: opts[:status],
      notes: opts[:notes],
    )
    ticket.soft_delete! unless pretend?
    puts 'Deleted.'
    puts ticket if debug?
  end

  def undelete(board, ticket)
    ticket = find_one_ticket(
      board: board,
      ticket: ticket,
      title: opts[:title],
      pr: opts[:pr],
      repo: opts[:repo],
      status: opts[:status],
      notes: opts[:notes],
      deleted: true
    )
    ticket.undelete!(status: opts[:status] || "p")
    puts 'Undeleted.'
    puts ticket if debug?
  end

  def clean_deploys
    Slork.where(deleted_at: nil, status: ["D", "o", "x"]).all.each do |slork|
      puts "Cleaning ticket #{slork}"
      slork.soft_delete! unless pretend?
    end
  end

  def move_into_review(board, ticket)
    ticket = find_one_ticket(
      board: board,
      ticket: ticket,
      title: opts[:title],
      repo: opts[:repo],
      notes: opts[:notes],
    )
    pr = opts[:pr] || get_command_output('git get-pr-id --quiet')

    if !pretend?
      ticket.set_pr!(pr) if pr != ""
      puts "Set PR id of #{ticket} to #{pr}."
    end
    ticket.move_into_review! unless pretend?
    puts "Moved #{ticket} into review."

    puts ticket if debug?
  end

  def update_project_code(board, ticket)
    ticket = find_one_ticket(
      board: board,
      ticket: ticket,
      title: opts[:title],
      repo: opts[:repo],
      notes: opts[:notes],
    )

    ticket.project_code = ARGV[2]
    ticket.save
  end

  def set_branch(board, ticket, branch)
    branch ||= git_current_branch
    puts "Setting branch to #{branch.inspect}..."
    ticket = find_one_ticket(
      board: board,
      ticket: ticket,
      title: opts[:title],
      repo: opts[:repo],
      notes: opts[:notes],
    )

    ticket.branch = branch
    ticket.save
  end

  def record_time(board, ticket)
    raise "record_time not yet implemented"
  end

  def ready(board, ticket)
    ticket = find_one_ticket(
      board: board,
      ticket: ticket,
      title: opts[:title],
      repo: opts[:repo],
      notes: opts[:notes],
    )

    ticket.mark_ready_to_deploy!
  end

  def deploy(board, ticket)
    ticket = find_one_ticket(
      board: board,
      ticket: ticket,
      title: opts[:title],
      repo: opts[:repo],
      notes: opts[:notes],
    )

    ticket.mark_deployed!
  end

  def go_to_branch_for(board, ticket)
    ticket = find_one_ticket(board:, ticket:)

    # abort unless git-isclean OR --force
    if !git_isclean && !force?
      puts "You have unstaged changes. Commit or stash them, or rerun with --force." unless quiet?
      exit 1
    end

    # abort if target branch is this branch
    current_branch = git_current_branch
    if ticket.branch == current_branch
      puts "You are already on branch '#{current_branch}'. My work here is done." unless quiet?
      exit 0
    end

    run_command "go '#{ticket.branch}'"
  end

  def mark_done(board, ticket)
    ticket = find_one_ticket(
      board: board,
      ticket: ticket,
      repo: opts[:repo]
    )

    ticket.notes = opts[:notes] if opts[:notes_given]
    ticket.status = 'o'
    ticket.save
    puts 'Marked done.'
    puts ticket if debug?
  end

  def mark_abandoned(board, ticket)
    ticket = find_one_ticket(
      board: board,
      ticket: ticket,
      repo: opts[:repo]
    )

    ticket.notes = opts[:notes] if opts[:notes_given]
    ticket.status = 'x'
    ticket.save
    puts 'Marked abandoned.'
    puts ticket if debug?
  end

  def mark_ready_for_qa(board, ticket)
    ticket = find_one_ticket(
      board: board,
      ticket: ticket,
      repo: opts[:repo]
    )

    ticket.notes = opts[:notes] if opts[:notes_given]
    ticket.status = 'q'
    ticket.save
    puts 'Marked as in QA.'
    puts ticket if debug?
  end

  def mark_in_progress(board, ticket)
    ticket = find_one_ticket(
      board: board,
      ticket: ticket,
      repo: opts[:repo]
    )

    ticket.notes = opts[:notes] if opts[:notes_given]
    ticket.status = 'p'
    ticket.save
    puts 'Marked as in progress.'
    puts ticket if debug?
  end

  def update_notes(board, ticket)
    ticket = find_one_ticket(
      board: board,
      ticket: ticket,
      title: opts[:title],
      pr: opts[:pr],
      repo: opts[:repo],
      status: opts[:status],
    )
    opts[:notes] = ARGV[2] unless opts[:notes_given]

    ticket.notes = opts[:notes]
    ticket.save
    puts 'Updated note.'
    puts ticket if debug?
  end

  def update_title(board, ticket)
    ticket = find_one_ticket(
      board: board,
      ticket: ticket,
      notes: opts[:notes],
      pr: opts[:pr],
      repo: opts[:repo],
      status: opts[:status],
    )
    opts[:title] = ARGV[2] unless opts[:title_given]

    ticket.title = opts[:title]
    ticket.save
    puts 'Updated title.'
    puts ticket if debug?
  end

  def update_pr(board, ticket)
    ticket = find_one_ticket(
      board: board,
      ticket: ticket,
      title: opts[:title],
      status: opts[:status],
      repo: opts[:repo],
      notes: opts[:notes],
    )
    Optimist::die "No PR given, please set with --pr=<id>" unless opts[:pr]

    opts[:pr] = ARGV[2] unless opts[:pr_given]

    ticket.pr = opts[:pr]
    ticket.save
    puts 'Updated pr.'
    puts ticket if debug?
  end

  def update_status(board, ticket)
    ticket = find_one_ticket(
      board: board,
      ticket: ticket,
      title: opts[:title],
      pr: opts[:pr],
      repo: opts[:repo],
      notes: opts[:notes],
    )
    Optimist::die "New status #{opts[:status].inspect} must be one of #{KNOWN_STATUSES.keys.inspect}" unless KNOWN_STATUSES.include?(opts[:status])
    opts[:status] = ARGV[2] unless opts[:status_given]
    ticket.status = opts[:status]
    ticket.save
    puts 'Updated status.'
    puts ticket if debug?
  end
end


if __FILE__ == $0
  Application.new.run
end
