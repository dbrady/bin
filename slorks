#!/usr/bin/env ruby
# slorks - Track branch/pr/ticket and show slackups
#
# General Usage:
#
# slorks - generate table at terminal for my quick review
# slorks -m, --markdown - generate markdown for slackup
# slorks new [<ticket>|--board=<jira_team> --ticket=<jira_ticket_number>] --title=<title> - create new slork
# slorks delete <ticket_details> - delete a slork (ticket_details must locate exactly 1 ticket)
# slorks update <ticket_details> <new_ticket_details> (no idea how to do this. Find title then set title what)
#
# slorks [create|edit|update|list|show]
# $ slorks   --board=MPS --jira=199 --repo=merchant_portal --title="Remove spiff orders table" --status="p" --notes="blocked by MPS-209"
#

require "clipboard"
require "colorize"
require "erb"
require "extralite"
require "optimist"
require "sequel"
require "text-table"
require_relative "dbrady_cli"
String.disable_colorization unless $stdout.tty?

class Application
  include DbradyCli

  opt_flag :markdown

  COMMANDS = {
    "c" => "Open database console",
    "console" => "Open database console",
    "clean" => "Soft-delete all deployed tickets (use after reporting them as deployed)",
    "delete" => "Soft-delete ticket",
    "deploy" => "Mark ticket as Deployed",
    "new" => "Create new ticket (automatically called from git-new-branch)",
    "notes" => "Edit ticket notes",
    "pr" => "Edit ticket PR",
    "ready" => "Mark ticket as ready for deploy",
    "review" => "Mark ticket as in review",
    "status" => "Edit ticket status",
    "undelete" => "Undelete a ticket (provide new status, default is 'p')",
  }.freeze
  DATABASE_PATH = File.expand_path('~/bin/db/git-settings.db')
  DB = Sequel::sqlite(DATABASE_PATH)

  KNOWN_STATUSES = {
    "b" => "Blocked",
    "r" => "In Review",
    "q" => "QA Review",
    "p" => "In Progress",
    "d" => "Ready to Deploy",
    "D" => "Deployed",
    "x" => "Abandoned",
    "o" => "Done",
    ">" => "Deferred",
  }
  DEFAULT_REPO="merchant_portal"
  DEFAULT_BOARD="CREDIT"

  if !ARGV.include?("create")
    class Slork < Sequel::Model(DB[:slorks])
      plugin :timestamps, update_on_create: true

      class <<self
        def find_ticket(board: nil, ticket: nil, title: nil, pr: nil, repo: nil, status: nil, notes: nil, deleted: false)
          search = self
          search = search.where(board:) if board
          search = search.where(ticket:) if ticket
          search = search.where(Sequel.ilike(:title, "%#{title}%")) if title
          search = search.where(pr:) if pr
          search = search.where(repo:) if repo
          search = search.where(status:) if status
          search = search.where(Sequel.ilike(:notes, "%#{notes}%")) if notes
          # search for where deleted_at is NOT null if deleted is true
          search = search.where(Sequel.~(deleted_at: nil)) if deleted

          search.all
        end
      end

      # Returns the full jira ticket, like MPS-42 or COR-781 or COVID-19
      def ticket_key
        "#{board}-#{ticket}"
      end

      # https://github.com/acima-credit/merchant_portal/pull/13287 | https://upbd.atlassian.net/browse/ATD-1401
      def pr_link
        return nil unless pr

        "https://github.com/acima-credit/#{repo}/pull/#{pr}"
      end

      def jira_link
        return nil unless board && ticket

        "https://upbd.atlassian.net/browse/#{board}-#{ticket}"
      end

      def status_text
        KNOWN_STATUSES[status] || status
      end

      def soft_delete!
        self.deleted_at = Time.now
        save
      end

      def move_into_review!
        self.status = 'r'
        save
      end

      def mark_ready_to_deploy!
        self.status = 'd'
        save
      end

      def mark_deployed!
        self.status = 'D'
        save
      end

      def set_pr!(pr)
        self.pr = pr
        save
      end

      def undelete!(status: "p")
        self.deleted_at = nil
        self.status = status
        puts self.inspect
        save
      end
    end
  end

  def run
    @opts = Optimist.options do
      banner <<BANNER.gsub(/<STATUSES>/, KNOWN_STATUSES.each_pair.map {|key,value| "  #{key}: #{value}"}.join("\n")).gsub(/<COMMANDS>/, COMMANDS.each_pair.map {|key, value| "  #{key.ljust(10)} - #{value}" }.join("\n"))
Generate and update tickets and PRs for slackup.

slorks [<command> [<ticket>]] [<options>]

slorks    - list slorks to the console as a text table
slorks -m - list slorks as markdown for slackup

Commands:

<COMMANDS>

Statuses:
<STATUSES>

Options:
BANNER
      opt :debug, "Print extra debug info", default: false
      opt :pretend, "Print commands but do not run them", default: false
      opt :verbose, "Run with verbose output (overrides --quiet)", default: false
      opt :quiet, "Run with minimal output", default: false

      opt :markdown, "Display output as markdown for Slack", default: false

      opt :board, "Jira board", type: :string, default: DEFAULT_BOARD
      opt :ticket, "Jira ticket number", type: :int
      opt :title, "Title of PR", type: :string
      opt :pr, "ID of PR", type: :int
      opt :repo, "Repository slug", type: :string, default: DEFAULT_REPO
      opt :status, "Status text", type: :string
      opt :notes, "Notes text", type: :string

      # opt :branch, "Get jira board and id from branch, and if available, get pr id", short: :none, default: false
    end
    puts opts.inspect if opts[:debug]
    opts[:quiet] = !opts[:verbose] if opts[:verbose_given]
    puts opts.inspect if opts[:debug]

    argv = ARGV.dup
    command = argv.shift&.downcase
    Optimist::die "Command #{command.inspect} must be one of: #{COMMANDS.keys.inspect}" unless command.nil? || COMMANDS.keys.include?(command)

    ensure_table_exists! if command == "create"

    if !opts[:board_given] && !opts[:ticket_given] && ARGV[1] =~ /^([A-Z]+)-(\d+)$/
      opts[:board], opts[:ticket] = $1, $2
      opts[:board_given] = true
      opts[:ticket_given] = true
    end

    puts ["Board: #{opts[:board]}", "Ticket: #{opts[:ticket]}"] if debug?

    case command
    when "console", "c" then run_command "sqlite3 -table #{DATABASE_PATH}"
    when "new" then add_new
    when "clean" then clean_deploys
    when "delete" then soft_delete
    when "deploy" then deploy
    when "ready" then ready
    when "review" then move_into_review
    when "status" then update_status
    when "pr" then update_pr
    when "notes" then update_notes
    when "undelete" then undelete
    else
      if markdown?
        puts list_as_markdown if markdown?
        copy_list_as_markdown
      else
        # copy to markdown unless --no-markdown is explicitly given
        copy_list_as_markdown unless opts[:markdown_given] && !markdown?
        puts list
      end
      log_list
    end
  end

  def list
    return @list if @list
    table = Text::Table.new
    table.head = %i(board ticket repo pr title status notes pr_link jira_link)
    Slork.where(deleted_at: nil).order(:created_at, "ASC").all.each do |slork|
      table.rows << [slork.board, slork.ticket, slork.repo, slork.pr, slork.title, slork.status_text, slork.notes, slork.pr_link, slork.jira_link]
    end
    @list = table.to_s
  end

  def copy_list_as_markdown
    Clipboard.copy(list_as_markdown)
    puts "Slackup report copied to clipboard."
  end

  # TODO: If this gets used a lot, write a proper reporting system for it
  # I expect this to be useful when compiling my weekly time sheets but
  # let's see before we commit. YAGNI.
  #
  # This could also be served by adding an audit log to the Slork model
  # and keep the changes in the database.
  def log_list
    folder = File.expand_path "~/bin/db/logs"
    filename = "slorks.#{Time.now.strftime("%Y%m%d.%H%M%S")}.log"
    full_path = File.join folder, filename
    Dir.mkdir folder unless Dir.exist? folder

    puts "path_to_last_log: #{path_to_last_log}" if debug?
    puts "log_has_changed? #{log_has_changed?(path_to_last_log, list)}" if debug?

    if log_has_changed?(path_to_last_log, list)
      write_log(full_path, list)
    else
      puts "No changes to log."
    end
  end

  def log_has_changed?(path, list)
    return true unless path && list && File.exist?(path)
    if debug?
      puts "File.read(path): #{File.read(path)}"
      puts "--"
      puts "list: #{list}"  
    end
    File.read(path) != list
  end

  def path_to_last_log
    folder = File.expand_path "~/bin/db/logs"
    Dir.glob(File.join(folder, "slorks.*.log")).sort.last
  end

  def write_log(full_path, list)
    File.open full_path, 'w' do |f|
      f.puts list
    end
    puts "Logged to #{full_path}" unless quiet?
  end

  def list_as_markdown
    list = []
    slorks = Slork.where(deleted_at: nil).order(:created_at).all
    slorks.each.with_index(1) do |slork, index|
      template_lines = []
      template_lines << "*Title:* <%= slork.title %>"
      template_lines << "*Ticket:* <%= slork.jira_link %>" if slork.jira_link
      template_lines << "*PR:* <%= slork.pr_link %>" if slork.pr_link
      template_lines << "*Status:* <%= slork.status_text %>"
      template_lines << "*Notes:* <%= slork.notes %>" if slork.notes

      template = template_lines * "\n"

      list << ERB.new(template).result(binding)
      list << '--' if index < slorks.size
    end
    list * "\n"
  end

  def ensure_table_exists!
    DB.create_table?(:slorks, if_not_exists: true) do
      primary_key :id
      String :repo, null: false
      String :board, null: false
      Integer :ticket, null: false
      Integer :pr
      String :title, null: false
      String :status, null: false
      String :notes

      DateTime :created_at
      DateTime :updated_at
      DateTime :deleted_at
    end
  end

  def add_new
    board, ticket = get_board_and_ticket_from_branch
    board = opts[:board] if opts[:board_given]
    ticket = opts[:ticket] if opts[:ticket_given]

    # if an undeleted ticket exists matching board and ticket, abort
    if Slork.find_ticket(board:, ticket:).any?
      puts "Ticket already exists. Aborting.".red
      exit 1
    end

    slork = Slork.new(
      board:,
      ticket:,
      repo: opts[:repo],
      pr: opts[:pr],
      title: opts[:title],
      status: opts[:status] || 'p',
      notes: opts[:notes]
    )

    puts slork.inspect

    slork.save unless pretend?
  end

  def find_one_ticket(board: nil, ticket: nil, title: nil, pr: nil, repo: nil, status: nil, notes: nil, deleted: false)
    puts "Finding ticket: #{ {board:, ticket:, title:, pr:, repo:, status:, notes:}.inspect }" if debug?
    tickets = Slork.find_ticket(board:, ticket:, title:, pr:, repo:, status:, notes:, deleted:)

    if tickets.size != 1
      puts tickets.map(&:inspect) if debug?
      raise "Expected exactly 1 ticket to be found, got #{tickets.size}"
    end

    tickets.first
  end

  def soft_delete
    ticket = find_one_ticket(
      board: opts[:board],
      ticket: opts[:ticket],
      title: opts[:title],
      pr: opts[:pr],
      repo: opts[:repo],
      status: opts[:status],
      notes: opts[:notes],
    )
    ticket.soft_delete! unless pretend?
    puts "Deleted."
    puts ticket if debug?
  end

  def undelete
    ticket = find_one_ticket(
      board: opts[:board],
      ticket: opts[:ticket],
      title: opts[:title],
      pr: opts[:pr],
      repo: opts[:repo],
      status: opts[:status],
      notes: opts[:notes],
      deleted: true
    )
    ticket.undelete!(status: opts[:status] || "p")
    puts "Undeleted."
    puts ticket if debug?
  end

  def clean_deploys
    Slork.where(deleted_at: nil, status: ["D", "o", "x"]).all.each do |slork|
      puts "Cleaning ticket #{slork.ticket_key}"
      slork.soft_delete! unless pretend?
    end
  end

  def move_into_review
    board, ticket = if opts[:board_given] && opts[:ticket_given]
                      [opts[:board], opts[:ticket]]
                    else
                      get_board_and_ticket_from_branch
                    end
    ticket = find_one_ticket(
      board: board,
      ticket: ticket,
      title: opts[:title],
      repo: opts[:repo],
      notes: opts[:notes],
    )
    Optimist::die "You must specify --pr to move ticket into review" unless opts[:pr_given]
    ticket.set_pr!(opts[:pr]) unless pretend?
    puts "Set PR."
    ticket.move_into_review! unless pretend?
    puts "Moved into review."

    assign_message = "@robby assign #{opts[:pr]}"
    run_command %Q(echo "#{assign_message}" | pbcopy)
    puts ticket if debug?
  end

  def ready
    board, ticket = get_board_and_ticket_from_branch
    board = opts[:board] if opts[:board_given]

    ticket = find_one_ticket(
      board: board,
      ticket: ticket,
      title: opts[:title],
      repo: opts[:repo],
      notes: opts[:notes],
    )

    ticket.mark_ready_to_deploy!
  end

  def deploy
    board, ticket = get_board_and_ticket_from_branch
    board = opts[:board] if opts[:board_given]

    ticket = find_one_ticket(
      board: board,
      ticket: ticket,
      title: opts[:title],
      repo: opts[:repo],
      notes: opts[:notes],
    )

    ticket.mark_deployed!
  end


  def update_notes
    ticket = find_one_ticket(
      board: opts[:board],
      ticket: opts[:ticket],
      title: opts[:title],
      pr: opts[:pr],
      repo: opts[:repo],
      status: opts[:status],
    )
    opts[:notes] = ARGV[2] unless opts[:notes_given]

    ticket.notes = opts[:notes]
    ticket.save
    puts "Updated note."
    puts ticket if debug?
  end

  def update_pr
    search = {}
    search[:board] = opts[:board] if opts[:board]
    search[:ticket] = opts[:ticket] if opts[:ticket]

    ticket = find_one_ticket(
      board: opts[:board],
      ticket: opts[:ticket],
      title: opts[:title],
      status: opts[:status],
      repo: opts[:repo],
      notes: opts[:notes],
    )
    Optimist::die "No PR given, please set with --pr=<id>" unless opts[:pr]

    opts[:pr] = ARGV[2] unless opts[:pr_given]

    ticket.pr = opts[:pr]
    ticket.save
    puts "Updated pr."
    puts ticket if debug?
  end

  def update_status
    search = {}
    search[:board] = opts[:board] if opts[:board]
    search[:ticket] = opts[:ticket] if opts[:ticket]

    ticket = find_one_ticket(
      board: opts[:board],
      ticket: opts[:ticket],
      title: opts[:title],
      pr: opts[:pr],
      repo: opts[:repo],
      notes: opts[:notes],
    )
    Optimist::die "New status #{opts[:status].inspect} must be one of #{KNOWN_STATUSES.keys.inspect}" unless KNOWN_STATUSES.include?(opts[:status])
    opts[:status] = ARGV[2] unless opts[:status_given]
    ticket.status = opts[:status]
    ticket.save
    puts "Updated status."
    puts ticket if debug?
  end
end


if __FILE__ == $0
  Application.new.run
end
