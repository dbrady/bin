#!/usr/bin/env ruby
# git-remaster [<parent-branch-name>] - pull down parent branch and rebase it into this branch
require "colorize"
require "optimist"
require_relative "lib/dbrady_cli"
String.disable_colorization unless $stdout.tty?

class Application
  include DbradyCli

  opt_flag :bundle, :migrate, :flowchart, :merge, :recurse, :stash

  def run
    original_args = ARGV.dup
    @opts = Optimist.options do
      opt :bundle, "Run bundle install", default: false
      opt :debug, "Print extra debug info", default: false
      opt :flowchart, "Show mermaid flowchart and exit", default: false
      opt :merge, "Merge parent branch in instead of rebasing", default: false
      opt :migrate, "Run any new database migrations", default: false
      opt :pretend, "Print commands but do not run them", default: false
      opt :quiet, "Run with minimal output", default: false
      opt :recurse, "Recurse all the way to master", default: false
      opt :stash, "Stash and reapply changes around rebase", default: false
      opt :verbose, "Run with verbose output (overrides --quiet)", default: false
    end
    opts[:quiet] = !opts[:verbose] if opts[:verbose_given]

    if opts[:flowchart]
      puts flowchart
      exit
    end

    current_branch = `git current-branch`.strip
    main_branch = git_main_branch
    parent_branch = ARGV.first || git_parent_or_main_branch

    if debug?
      puts "current_branch: #{current_branch}"
      puts "parent_branch: #{parent_branch}"
      puts "main_branch: #{main_branch.inspect}"
      puts "main_branch != parent_branch && recurse?: #{(main_branch != parent_branch && recurse?).inspect}"
      puts "main_branch != parent_branch: #{(main_branch != parent_branch).inspect}"
      puts "recurse?: #{recurse?.inspect}"
      puts opts.inspect
    end

    if branch_is_dirty? && !stash?
      puts "Your branch has outstanding changes. Rerun with --stash if you want to stash/rebase/reapply them, or --no-stash if you want to live dangerously.".red
      exit -1
    end

    debug ">>> ENTERING REMASTER OF #{current_branch}"
    debug "recurse is on" if recurse?
    if recurse? && main_branch != parent_branch
      debug "Recursing to parent branch '#{parent_branch}'"
      run_command "git checkout '#{parent_branch}'"

      # make sure the git co actually worked so we don't forkbomb
      new_current_branch = git_current_branch

      if new_current_branch == current_branch
        puts "COULD NOT CHANGE BRANCH. ABORTING".bold.white.on_red
        exit
      end

      # recurse
      debug '-' * 80
      puts "current_branch: #{current_branch.inspect}"
      puts "parent_branch: #{parent_branch.inspect}"
      puts "main_branch: #{main_branch.inspect}"
      debug '-' * 80
      if parent_branch == main_branch
        debug "Parent branch is #{parent_branch}, my work is done here."
      else
        run_command "git-remaster #{original_args * ' '}"
      end

      debug "Returning to child branch '#{current_branch}'"
      run_command "git checkout '#{current_branch}'"
    end

    # if the branch is not rebasable, turn on --merge
    debug "branch_is_rebasable? #{branch_is_rebasable?.inspect}"
    if !branch_is_rebasable? && !opts[:merge]
      # TODO: I still need the ability to set the rebase/merge values here
      $stderr.puts "Branch is not rebasable; using merge strategy.".yellow unless quiet?
      opts[:merge_given] = opts[:merge] = true
    end

    stashed = if branch_is_dirty? && stash?
                run_command("git stash")
              end

    commands = [
      "git checkout #{parent_branch}",
      "git pull",
      "git checkout #{current_branch}",
    ]
    rebase_or_merge_command = merge? ? "merge" : "rebase"
    commands << "git #{rebase_or_merge_command} #{parent_branch}" unless current_branch == "master"

    run_command_chain commands

    run_command "bundle" if bundle?
    run_command "remigrate -f" if migrate?

    run_command "git stash apply" if stashed
    debug "<<<< EXITING REMASTER OF #{current_branch}"
  end

  def debug(message)
    return unless debug?

    puts message.magenta
  end

  def flowchart
    tmp = <<PANTS
graph TD
    A[Enter Chart Definition] --> B(Preview)
    B --> C{decide}
    C --> D[Keep]
    C --> E[Edit Definition]
    E --> B
    D --> F[Save Image and Code]
    F --> B
    id
PANTS

    str = <<FLOWCHART
---
Title: git remaster
---
flowchart TD
    start[Start]
    is_clean{git isclean}
    git_stash{git stash}
    go_parent(git checkout parent)
    git_pull(git_pull)
    go_branch(git checkout branch)
    git_rebase(git rebase parent)
    was_clean{Was git isclean clean?}
    stash_apply(git stash apply)
    done[Done]

    start-->is_clean
    is_clean-->|Yes|go_parent
    is_clean-->|No|git_stash

    git_stash-->go_parent
    go_parent-->git_pull
    git_pull-->go_branch
    go_branch-->git_rebase
    git_rebase-->was_clean
    was_clean-->|Yes|done
    was_clean-->|No|stash_apply
    stash_apply-->done
FLOWCHART

    str
  end

  def run_command_chain(commands)
    commands.each do |command|
      success = run_command(command)
      if !success
        puts "Command failed: #{command}".red
        exit -1
      end
    end
  end

  # Returns true if there are any staged or unstaged changes (but does not care if
  # there are untracked files)
  def branch_is_dirty?
    return @branch_is_dirty if @branch_is_dirty_is_cached

    puts "Checking to see if branch is clean..."
    @branch_is_dirty = !run_command("git isclean")
    @branch_is_dirty_is_cached = true
    @branch_is_dirty
  end

  def branch_is_rebasable?
    @branch_is_rebasable ||= run_command 'git rebasable'
  end
end


if __FILE__ == $0
  Application.new.run
end
