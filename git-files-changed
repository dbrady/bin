#!/usr/bin/env ruby
# git-files-changed (<n>|<sha>|<sha1>..<sha2>) - Show files changed since sha or in the last n commits
# See Also: git-modified for uncommitted changed files
require "colorize"
require "debug"
require "optimist"
require_relative "lib/dbrady_cli"
String.disable_colorization unless $stdout.tty?

class Application
  include DbradyCli

  opt_flag :merge_base, :ruby

  def include_deleted?
    opts[:deleted]
  end

  def run
    @opts = Optimist.options do
      banner <<~BANNER
git files-changed - show list of files changed in a range of commits

git files-changed [options] (<n>|<sha1>|<sha1>..<sha2>) [1]

git files-changed <n>                             - Show files changed in the last n commits
git files-changed <since_commit>                  - Show files changed since a commit or branch
git files-changed <since_comment>..<until_commit> - Show files changed in a range of commits

Examples:

git files-changed                  - Show files changed since diverging from main [2]
git files-changed 7                - Show files changed in the last 7 commits
git files-changed abcd1234         - Show files changed since commit abcd1234
git files-changed main             - Show files changed since you forked from main
git files-changed ab1234..cd5678   - Show files changed in a range of commits
git files-changed staging..release - Show files changed from one branch to another

Note 1: This tool assumes that <sha1> is an ancestor of <sha2>. If they are not,
git will cheerfully walk up the logs to of both branches back to their common
ancestor, and then show you the commits from one or both branches at its own
discretion. In my own tests, it's usually <common>..<sha2> but in once case it
gave me <common>..<sha1> followed by <common>..<sha2>. &shrug; (TODO: `git
merge-base thatbranch thisbranch` will tell us this.)

Note 2: With no arguments, we determine the name of the main/master branch, then calculate the merge-base for it.

See Also:

git modified - list files modified since last commit, whether staged or not
git specs-changed - same as files-changed but finds the affected specs

Options:
BANNER

      opt :debug, "Print extra debug info", default: false
      opt :exclude, "Filenames to exclude (fragment)", short: :x, type: :string, multi: true
      opt :deleted, "Include files that have been deleted and are no longer extant", short: :e, default: false
      opt :merge_base,"Calculate changes from the shared merge-base of the given branch", short: :m, default: false
      opt :only, "Pattern to include", short: :o, type: :string, multi: true
      opt :pretend, "Print commands but do not run them", default: false
      opt :quiet, "Run with minimal output", default: false
      opt :ruby, "Put ruby files in include pattern", default: false
      opt :verbose, "Run with verbose output (overrides --quiet)", default: false
    end
    opts[:quiet] = !opts[:verbose] if opts[:verbose_given]
    dump_opts if debug?

    repo = git_repo_for(Dir.pwd)

    opts[:only] << '*.rb' if ruby?

    range = "-n 10"

    # git files-changed abc123..def456
    # look at commits in that range
    # ARGV.first because "x..y" is one string
    ARGV.first

    range = if ARGV.empty?
              parent = git_parent_or_main_branch
              $stderr.puts "Diffing against branch: #{parent.inspect}" if verbose?
              if merge_base?
                parent = get_command_output "git merge-base #{parent} HEAD"
              end
              "#{parent}..HEAD"
            elsif ARGV.size == 2
              # git files-changed abc123 def456
              ARGV.join('..')
            elsif ARGV.first =~ /^\d+$/
              # git files-changed 5
              # look at last 5 commits
              "-n #{ARGV.first}"
            elsif ARGV.first&.start_with?("..")
              # git files-changed abc123..def456
              # look at commits in that range
              # ARGV.first because "x..y" is one string
              ARGV.first
            else
              # git files-changed abc123
              # look at abc123..HEAD
              parent = ARGV.first
              parent = get_command_output "git merge-base #{parent} HEAD" if merge_base?
              "#{parent}..HEAD"
            end

    opts[:exclude] << ".*env*"

    files = get_command_output_lines "git log #{range} --name-only --pretty=format: | sed '/^$/d' | sort | uniq"

    # filter files through only_patterns, patterns_to_exclude, fragments_to_exclude
    opts[:only].each do |pattern|
      files = files.select {|filename| File.fnmatch(pattern, filename) }
    end
    files = files.reject {|filename| opts[:exclude].any? {|pattern| File.fnmatch(pattern, filename) }}

    files = files.reject {|filename| !File.exist?(File.join(repo, filename)) } unless include_deleted?

    puts files
  end
end


if __FILE__ == $0
  Application.new.run
end
