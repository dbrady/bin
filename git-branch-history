#!/usr/bin/env ruby
require 'colorize'
require 'date'
require 'optimist'
require 'extralite'

# Return previous Monday.
def start_of_week_for(date)
  date = Date.parse(date)
  date - (date.wday-1) % 7
end

# Return following Monday, that way datetimes on Sunday night will show up as
# less that DATE(next monday).
def end_of_week_for(date)
  start_of_week_for(date) + 7
end

# Return true if path contains a .git/ folder or a .git file (specific instance of a submodule)#
# Duplicate code in git-branch-history and git-log-branch. Is it make-a-git-tools-gem o'clock yet?
def is_git_repo?(path)
  File.exists?(File.join(path, '.git'))
end

# Walk up file tree looking for a .git folder
# Duplicate code in git-branch-history and git-log-branch. Is it make-a-git-tools-gem o'clock yet?
def git_repo_for(path)
  starting_path = last_path = path

  while !path.empty?
    return path if is_git_repo?(path)
    last_path, path = path, File.split(path).first
    raise " FIGURE OUT PATH FOR #{starting_path.inspect}" if last_path == path
  end
end

opts = Optimist::options do
  banner <<-USAGE
git-branch-history - query the branch history log

By default, gets the branch history of the current repo for last week

If --date is given, --start and --end will be overridden to the Mon-Sun week containing that date.

If none of --start, --end, or --date are given, defaults to last week.
USAGE

  opt :start, "Start date", short: :none, type: :string
  opt :end, "End date", short: :none, type: :string
  opt :date, "Sets --start and --end to week of Mon-Sun containing this date, or --date=today for current week", short: :none, type: :string

  opt :latest, "Show only latest/current branches for each path only", default: false
  opt :log, "Show journal/log of branch changes", default: false
  opt :all, "Show branch history for all recorded repos", default: false
  opt :path, "Path to specific repo (defaults to current folder)", type: :string

  opt :debug, "Dump extra debug information", short: :d, default: false
  opt :verbose, "Be a bit extra chatty", default: false
end

puts "Opts exactly as given: #{opts.inspect}" if opts[:debug]

Optimist::die("Cannot specify both --all and --path") if opts[:all_given] && opts[:path_given]

opts[:path] = if opts[:all]
                nil # force nil; otherwise
              elsif opts[:path_given]
                git_repo_for(File.expand_path(opts[:path]))
              else
                git_repo_for(Dir.pwd)
              end

puts "Path to repo is '#{opts[:path]}'" if opts[:debug]

if !opts[:date_given] && !opts[:start_given] && !opts[:end_given]
  opts[:date] = Date.today.strftime("%F") # (Date.today - 7).strftime("%F")
  opts[:date_given] = true # force the date_given math to happen next
end

opts[:date] = Date.today.strftime("%F") if opts[:date].downcase == "today"
if opts[:date_given]
  opts[:start] = start_of_week_for(opts[:date]).strftime("%F")
  opts[:end] = end_of_week_for(opts[:date]).strftime("%F")
end

puts "Opts after processing: #{opts.inspect}" if opts[:debug]

SHARE_FOLDER =  if ENV['IS_DOCKER_LOCAL'] == "1" then
                  File.expand_path('/root/data_services_package/dataservices/haxx')
                else
                  File.expand_path('/Users/davidbrady/acima/devel/data_services_package/dataservices/haxx')
                end

DATABASE_PATH = File.join(SHARE_FOLDER, 'git-branch-history.db')

wheres = []
wheres << "DATE(created_at) >= '#{opts[:start]}'" if opts[:start_given]
wheres << "DATE(created_at) < '#{opts[:end]}'" if opts[:end_given]
wheres << "path = '#{opts[:path]}'" if opts[:path]

where = if wheres.empty?
          ""
        else
          where = "WHERE " + wheres.join(" AND ")
        end

order = opts[:log] ? 'created_at' : 'path, branch'

db = Extralite::Database.new(DATABASE_PATH)

query = if opts[:latest]
            <<QUERY
SELECT path, branch, MAX(created_at) AS newest_created_at FROM branch_history #{where} GROUP BY path ORDER BY path
QUERY
          else
            <<QUERY
SELECT path, branch, created_at FROM branch_history #{where} ORDER BY #{order}
QUERY
          end

branches = Hash.new {|h,k| h[k] = []}

puts query.cyan if opts[:verbose]

db.execute(query) do |row|
  branches[row[:path]] << row[:branch]
end

branches.each_pair do |repo, branches|
  puts repo.cyan
  puts branches.map {|branch| "    #{branch}"}
end
